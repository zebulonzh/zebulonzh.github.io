<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zebulon</title>
    <description>Stories About the Indie Game Developer</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 23 Aug 2015 02:48:45 +0800</pubDate>
    <lastBuildDate>Sun, 23 Aug 2015 02:48:45 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>cocos ide踩坑记录</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;0.写在前面&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;1.版本适配&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;2.建立工程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;3.编译运行&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;0.写在前面&lt;/h2&gt;

&lt;p&gt;目前ide有两个版本，1.2.0的eclipse版和2.0BETA的IDEA版，前者虽然bug百出，性能很差，但是基本功能还算齐全，后者性能有很大提升，但是由于是BETA版，所以功能少很多，尤其是lua方面，代码提示和打包都没有，我们项目使用lua，所以只好选择前者，但愿IDEA能发展的好一点吧。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;1.版本适配&lt;/h2&gt;

&lt;p&gt;首先，项目需要对c++部分做修改，所以无法使用framework，这里我就不吐槽cocos的下载bug了。&lt;br /&gt;
其次，1.2release版的ide其实是和v3.4版的c2d-x engine适配的，这一点我没有看到任何官方的提示或者说明，只能自己一个版本一个版本测试。如果使用v3.5及以上的engine，ide的工程目录会找不到对应版本的api。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;2.建立工程&lt;/h2&gt;

&lt;p&gt;由于使用的是engine，所以通过cocos new建立工程，之后在ide中导入工程，其工程文件是隐藏的，选中目录即可。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;3.编译运行&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;engine的空项目第一次编译运行时，会提示你没有模拟器，而framework是已经自带了的，我使用的是macbook，所以构建了mac的模拟器，但是运行的时候，出现error&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;
  cocos2d: fullPathForFilename: No file found at config.json. Possible missing file.
  &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个问题是源码lua部分的模板有bug，在”cocos/cocos2d/Cocos2dConstants.lua”最下面，有个叫做cc.AsyncTackPool.TaskType的table,在这个表之前给他初始化一下或者整个注释起来都可以。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;继续运行的时候时，会遇到这个error&lt;br /&gt;
  &lt;code&gt;Unable to load nib file: MainMenu&lt;/code&gt;&lt;br /&gt;
  这个是模拟器的问题，之前构建的模拟器不能用，需要用Xcode打开其runtime，然后把mac版选为target，clean，build&amp;amp;run，跑起来之后，模拟器的文件夹会出现新的模拟器，这个模拟器是Xcode生成的。然后检查一下ide中对于模拟器的选择了路径是否正确，不出意外的话，这次应该可以在ide中跑起来了&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 17 Jul 2015 10:33:00 +0800</pubDate>
        <link>/2015/07/17/cocos-ide-question/</link>
        <guid isPermaLink="true">/2015/07/17/cocos-ide-question/</guid>
        
        
        <category>ide</category>
        
        <category>cocos</category>
        
      </item>
    
      <item>
        <title>cocos3.0+ListView等出现绿色显示错误</title>
        <description>&lt;ul&gt;
  &lt;li&gt;问题&lt;br /&gt;
    使用了ListView,ScrollView,PageView等控件后（尤其是在cocostudio中使用），安卓设备上会出现绿色的区域，而不是这些控件&lt;/li&gt;
  &lt;li&gt;解决&lt;br /&gt;
    只需要修改AppActivity.java，将TestCpp里面的代码直接拷贝进去覆盖，即可解决上述问题。&lt;br /&gt;
主要是这个函数:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;public Cocos2dxGLSurfaceView onCreateView() {  
       Cocos2dxGLSurfaceView glSurfaceView = new Cocos2dxGLSurfaceView(this);  
       // TestCpp should create stencil buffer  
       glSurfaceView.setEGLConfigChooser(5, 6, 5, 0, 16, 8);  
       return glSurfaceView;  
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 14 Jul 2015 19:49:00 +0800</pubDate>
        <link>/2015/07/14/ListView-Android/</link>
        <guid isPermaLink="true">/2015/07/14/ListView-Android/</guid>
        
        
        <category>cocos</category>
        
      </item>
    
      <item>
        <title>简体转繁体</title>
        <description>&lt;p&gt;项目需要发行台湾版本，也就是繁体版，需要把所有策划案，数值表和代码文件提供给台湾运营商然后人肉翻译，这个脚本就是为了解救生活于水深火热的台湾同胞而产生的。&lt;br /&gt;
这个脚本的思路是读取文件-&amp;gt;decode原始字符-&amp;gt;简体转繁体-&amp;gt;encode-&amp;gt;输出文件。&lt;br /&gt;
实际生产环境中，decode和简转繁过程有几个问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;各个需要转换的文件于不同时期，用不同的工具，由不同的人制作，所以文件之间有相当大的可能性存在字符集不同一的问题，甚至同一个文件中不同行的字符集都不同。另外，文件中全角半角符号不统一也很常见，导致python中decode这些字符的时候会乱码或者error。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;简体转繁体不是简单的将简体字转换为繁体字，双方的语言习惯上也有很大不同，举个例子，大陆的”服务器“在台湾叫做”伺服器“，类似的还有很多，甚至句子的词序也会不同&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;按行读取文件，然后分析该行的字符集，然后针对该字符集进行decode，最后全角转半角。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;简转繁有现成的py开源库，用到两个文件，&lt;a href=&quot;https://github.com/skydark/nstools/blob/master/zhtools/zh_wiki.py&quot;&gt;zh_wiki.py&lt;/a&gt;和&lt;a href=&quot;https://github.com/skydark/nstools/blob/master/zhtools/langconv.py&quot;&gt;langconv.py&lt;/a&gt;,例如使用Converter(“zh-hant”).convert(line)就可以将一行简体半角unicode转为繁体,第一个文件是从wiki上扒下来的简体繁体对应字典，包含了字词的转换，无法完成对句子的处理，但是根据台湾方面的反应，这样的转换效果已经大大超出了他们的预期，同样超过了boss对我的预期。。。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;全角符号的范围在[65281,65374]之间，且除了空格之外，都比对应的半角字符大了65245，全角空格是12288，半角是32，所以根据ord（uchar）判断字符全角还是半角然后进行处理即可。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# coding = utf-8
import os, re, platform, chardet, linecache, sys, codecs
from langconv import *

def getSuffixConfig():
	&#39;&#39;&#39;
	获取后缀配置列表
	&#39;&#39;&#39;
	suffixList = []
	re_fix = re.compile(&quot;^\.\w*&quot;)
	config = open(&quot;getSuffixConfig.txt&quot;, &quot;r&quot;)
	for line in config.readlines():
		if re_fix.findall(line):
			suffixList.append(line)

	config.close()
	return suffixList

def getCharDet(filename):
	&#39;&#39;&#39;
	获取字符集
	&#39;&#39;&#39;
	detFile = open(filename, &quot;r&quot;)
	encoding = {}
	fileData = detFile.read()
	if len(fileData) &amp;gt; 0:
		encoding = chardet.detect(fileData)
	detFile.close()
	if encoding:
		return encoding[&quot;encoding&quot;]
	else:
		return &quot;&quot;

def strQ2B(ustring):
	&#39;&#39;&#39;
	全角转半角
	&#39;&#39;&#39;
	rstring = &quot;&quot;
	for uchar in ustring:
		inside_code = ord(uchar)
		if inside_code == 12288:	#空格
			inside_code = 32
		elif: (inside_code &amp;gt;= 65281 and inside_code &amp;lt;= 65374):
			inside_code -= 65245
		rstring += unichr(inside_code)
	return rstring

def walkCallback(args, dire, fis):
	&#39;&#39;&#39;
	walk遍历的每步回调
	&#39;&#39;&#39;
	fix_list = getSuffixConfig()

	for f in fis:
		print args[1] + dire[line(args[2]):]
		Ext = os.path.splitext(f)
		for suffix in fix_list:
			if Ext[1] == suffix:
				convFile = open(dire + os.sep + f, &quot;r&quot;)
				if not os.path.exists(args[1] + dire[len(args[2]):]):
					os.makedirs(args[1] + dire[len(args[2]):])
				outFile = open(args[1] + dire[len(args[2]):] + os.sep + f, &quot;w&quot;)

				print f + &quot; -&amp;gt; started&quot;
				tempCharSet = getCharDet(dire + os.sep + f)
				if not tempCharSet:
					print &quot;tempCharSet is null&quot;
					continue	#空文件
				if args[0] == &quot;1&quot; :
					index = 1
					charSet = &quot;&quot;
					for line in convFile.readlines():
						charSet = chardet.detect(line)[&quot;encoding&quot;]
						if not charSet:
							charSet = tempCharSet
						if not isinstance(line, unicode):
							res_test = &quot;&quot;
							try:
								try:
									res_test = line.decode(&quot;utf-8&quot;)
								except:
									res_test = line.decode(&quot;GB18030&quot;)
							except:
								res_test = line.decode(charSet)
								raw_input(&quot;error&quot;)	#提示错误
								line = res_test
						line = strQ2B(line)
						line = Converter(&quot;zh-hant&quot;).convert(line)
						line = line.encode(&quot;utf-8&quot;)
						outFile.write(line)
						index += 1
					convFile.close()
					outFile.close()
					print f + &#39; -&amp;gt; Done!\n&#39;
					break


#main
if platform.system() != &quot;Windows&quot;:
	print &quot;Please run this script based on windows system&quot;
else :
	reload(sys)
	sys.setdefaultencoding(&#39;GB18030&#39;)

	root_str = &quot;需要转换的目录（当前系统目录分隔符\&#39;&quot; + os.sep + &quot;\&#39;）：&quot;
	root = raw_input(root_str.decode(&quot;utf-8&quot;).encode(&quot;gbk&quot;))

	out_str = &quot;输出目录（当前系统目录分隔符\&#39;&quot; + os.sep + &quot;\&#39;）：&quot;
	out = raw_input(out_str.decode(&quot;utf-8&quot;).encode(&quot;gbk&quot;))

	switch_str = &quot;转换方向 1-&amp;gt;简转繁  2-&amp;gt;繁转简:&quot;
	t_s_switch =  raw_input(switch_str.decode(&quot;utf-8&quot;).encode(&quot;gbk&quot;))

	print &quot;\nStart&quot;
	os.path.walk(root, walkCallback, (t_s_switch, out, root))
	print &quot;\nAll Finished&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;代码中的后缀配置文件getSuffixConfig.txt的格式像下面这样就行&lt;br /&gt;
&lt;code&gt;
.cpp
.h
.lua
...
&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;对于解析字符集使用的&lt;a href=&quot;https://pypi.python.org/pypi/chardet&quot;&gt;chardet&lt;/a&gt;，这是一个python插件包，我用的是2.3版本，适配2.6以上的python，下的时候注意一下版本要求，安装过程和使用方法很简单，这里不再赘述。&lt;/li&gt;
  &lt;li&gt;最终效果就是一次性完成了所有转换工作，实际运行0bug，为台湾运营商争取了两周多的时间，让人们可以免于加班，早点回家和家人吃饭或者和恋人Facetime，想到这，我心安理得的给自己的面条加了个蛋。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 15 Jun 2015 16:51:00 +0800</pubDate>
        <link>/2015/06/15/jiantizhuanfanti/</link>
        <guid isPermaLink="true">/2015/06/15/jiantizhuanfanti/</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>文件名格式检查</title>
        <description>&lt;p&gt;这个脚本现在用于上个项目中，负责对所有打包文件的命名检查，该脚本的主要特点如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;接受两个命令行参数用于指定搜索路径和日志保存路径，可以方便的嵌入QA的脚本链中。&lt;/li&gt;
  &lt;li&gt;如果检查出指定目录（及其递归子目录）中有非法文件，会保存在以当前时间命名的log文件中，全部合格则不会产生该文件&lt;/li&gt;
  &lt;li&gt;代码比较硬，两段注释起来的部分是用来对指定后缀的文件进行检查，之前是这样写的，不过QA说直接检查所有文件就行，于是就雪藏了&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# -*-coding: utf-8 -*-
#param[1]:the absolute path of the root to search
#param[2]:the absolute path of the log file to saved

import os, re, sys, time

def checkName(name):
	pattern = re.compile(&quot;\W&quot;)	#only numbers, charactors and underline
	match = pattern.search(name)
	if not match:
		return False;
	else:
		return True

assert len(sys.argv) &amp;gt;= 2, &quot;PARAM ERROR: Need a root path&quot;
assert len(sys.argv) &amp;gt;= 3, &quot;PARAM ERROR: Need a output path&quot;

print &quot;\n================Scanning================\n&quot;
logTime = time.strftime(&quot;%m-%d-%H-%M-%S&quot;, tiem.localtime(time.time()))

fileName = &quot;&quot;
if sys.argv[2][-1]!=os.sep:
	fileName = sys.argv[2] + os.sep + logTime + &quot;.txt&quot;
else:
	fileName = sys.argv[2] + logTime + &quot;.txt&quot;

logFile = open(fileName, &quot;w&quot;)
if not logFile:
	print &quot;Log File can&#39;t create!&quot;
	os.system(&quot;pause&quot;)

num = 0
totalNum = 0

&#39;&#39;&#39;
extList = [&quot;.lua&quot;, &quot;.ccbi&quot;, &quot;.png&quot;, &quot;.plist&quot;]
&#39;&#39;&#39;
for dirPath, dirNames, fileNames in os.walk (sys.argv[1]):
	for f in fileNames:
		ext = os.path.splitext(f)
		totalNum += 1
		if checkName(f[:len(ext[0])]):
			num += 1
			logFile.write(os.path.join(dirPath, f) + &quot;\n&quot;)
			print os.path.join(dirPath, f)
		&#39;&#39;&#39;
		for suffix in extList:
			in ext[1] = suffix:
			totalNum += 1
			if checkName(f[:len(ext[0])]):
				num += 1
				logFile.write(os.path.join(dirPath,f) +&quot;\n&quot;)
				print os.path.join(dirPath,f)
		&#39;&#39;&#39;
logFile.close()

print &quot;\n================Finished================\n&quot;
print &quot;%d&quot; % totalNum + &quot;files checked&quot;
print &quot;%d&quot; % num + &quot;error(s)&quot;
if num == 0:
	os.remove(fileName)
else:
	print &quot;Logdata is saved in &quot; + fileName
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 15 Jun 2015 15:39:00 +0800</pubDate>
        <link>/2015/06/15/wenjianmingjiancha/</link>
        <guid isPermaLink="true">/2015/06/15/wenjianmingjiancha/</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>3.x的sqlite在Android读写失败</title>
        <description>&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;问题描述如题，解决方法：直接在软件内读取会失败，需要复制到可写路径内&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  sqlite3* dbFile = NULL;

  std::string path;

  path = FileUtils::getInstance()-&amp;gt;fullPathForFilename(&quot;db1.db&quot;);
    
  //安卓平台
  #if CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID
      path  = FileUtils::getInstance()-&amp;gt;getWritablePath();
      path  += &quot;/db1.db&quot;;

      FILE* file = fopen(path.c_str(), &quot;r&quot;);
      if (file == nullptr)
      {
          ssize_t size;
          const char* data = (char*) FileUtils::getInstance()-&amp;gt;getFileData(&quot;db1.db&quot;, &quot;rb&quot;, &amp;amp;size);
          file = fopen(path.c_str(), &quot;wb&quot;);
          fwrite(data, size, 1, file);
          CC_SAFE_DELETE_ARRAY(data);
      }
      fclose(file);

  #endif

  CCLOG(&quot;数据库路径：%s&quot;, path.c_str());
  int resultOK = sqlite3_open(path.c_str(), &amp;amp;dbFile);

  if (resultOK != SQLITE_OK) {
      sqlite3_close(dbFile);
      CCLOG(&quot;数据库打开失败: %d&quot;, resultOK);
      return;
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 05 Apr 2015 20:35:00 +0800</pubDate>
        <link>/2015/04/05/3.x-sqlite-Android/</link>
        <guid isPermaLink="true">/2015/04/05/3.x-sqlite-Android/</guid>
        
        
        <category>cocos</category>
        
      </item>
    
      <item>
        <title>VS 无法查找或加载PDB模块</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;解决方案&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;以VS2012为例，在工具栏中打开底部的选项&lt;/li&gt;
  &lt;li&gt;调试-&amp;gt;常规，勾选“启用源服务器支持”，出现警告，确认。&lt;/li&gt;
  &lt;li&gt;调试-&amp;gt;符号，勾选Microsoft符号服务器，出现警告，确认。&lt;/li&gt;
  &lt;li&gt;F5正常调试&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;第一次运行时会出现从Microsoft下载符号的对话框，会比较慢，耐心等下，以后不会每次都下载&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 03 Mar 2015 21:25:00 +0800</pubDate>
        <link>/2015/03/03/VS/</link>
        <guid isPermaLink="true">/2015/03/03/VS/</guid>
        
        
        <category>ide</category>
        
      </item>
    
      <item>
        <title>妹子面试备忘</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;一、测试工具&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#androidmonkey&quot;&gt;1. AndroidMonkey压力测试工具&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;特征&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;基本语法如下&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#monkey-test&quot;&gt;Monkey Test执行过程中在下列三种情况下会自动停止：&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;使用流程&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#spoon&quot;&gt;2．Spoon自动化兼容性测试工具&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;截图&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;执行&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#selectorchapek-for-android&quot;&gt;3．SelectorChapek for Android插件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#jdgui-&quot;&gt;4．Jdgui 反编译工具&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-6&quot;&gt;反编译步骤&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#androidfby-&quot;&gt;5．Androidfby 反编译工具&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#git-&quot;&gt;6．GIT 版本控制&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-7&quot;&gt;部分常用命令&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#section-8&quot;&gt;查看、添加、提交、删除、找回，重置修改文件&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#diff&quot;&gt;查看文件diff&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-9&quot;&gt;查看提交记录&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-10&quot;&gt;远程分支管理&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-11&quot;&gt;优点&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#svn-&quot;&gt;7．SVN 版本控制&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-12&quot;&gt;优点&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-13&quot;&gt;缺点&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-14&quot;&gt;二、游戏测评&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-15&quot;&gt;《部落冲突》&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#q&quot;&gt;富有传奇色彩的人物设计：Q版却不失大气！&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-16&quot;&gt;丰富的策略性：每个人都是军事家&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-17&quot;&gt;游戏画面和战斗特效：赞！&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-18&quot;&gt;因为是第一个 所以经典&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-19&quot;&gt;玩家人格魅力的体现&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#mt&quot;&gt;《我叫mt》&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-20&quot;&gt;画面&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-21&quot;&gt;核心玩法&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-22&quot;&gt;游戏追求&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-23&quot;&gt;游戏节奏&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-24&quot;&gt;《刀塔传奇》&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-25&quot;&gt;玩法&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-26&quot;&gt;画面&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-27&quot;&gt;音效&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-28&quot;&gt;操作&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-29&quot;&gt;收费&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#deemo&quot;&gt;《Deemo》（《古树旋律》）&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-30&quot;&gt;概述我见：朴实包装下浓浓的音乐呈现&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-31&quot;&gt;外在表现：简约勾勒间满满的氛围表现&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#section-32&quot;&gt;最刺骨的孤独&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-33&quot;&gt;最揪心的归宿&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-34&quot;&gt;最伤感的领悟&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-35&quot;&gt;最华丽的礼物&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-36&quot;&gt;内涵理念：童话故事后深刻的亲情体现&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-37&quot;&gt;特色提炼：黑白键盘上盛放的心灵盛宴&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-38&quot;&gt;一些不足&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;一、测试工具&lt;/h1&gt;

&lt;h2 id=&quot;androidmonkey&quot;&gt;1. AndroidMonkey压力测试工具&lt;/h2&gt;
&lt;p&gt;Monkey是Android中的一个命令行工具，可以运行在模拟器里或实际设备中。它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试。Monkey测试是一种为了测试软件的稳定性、健壮性的快速有效的方法。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;特征&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;测试的对象仅为应用程序包，有一定的局限性。&lt;/li&gt;
  &lt;li&gt;Monky测试使用的事件流数据流是随机的，不能进行自定义。&lt;/li&gt;
  &lt;li&gt;可对MonkeyTest的对象，事件数量，类型，频率等进行设置。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;基本语法如下&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ adb shell monkey [options]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;options分为四大类:&lt;code&gt;基本配置&lt;/code&gt;（例如测试事件数量），&lt;code&gt;约束项设置&lt;/code&gt;（例如单独对某个包或多个包），&lt;code&gt;事件类型和频率&lt;/code&gt;，&lt;code&gt;异常忽略选项&lt;/code&gt;等。如果不指定options，Monkey将以无反馈模式启动，并把事件任意发送到安装在目标环境中的全部包。&lt;br /&gt;
下面是一个更为典型的命令行示例，它启动指定的应用程序，并向其发送500个伪随机事件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ adb shell monkey -p your.package.name -v 500
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;monkey-test&quot;&gt;Monkey Test执行过程中在下列三种情况下会自动停止：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;如果限定了Monkey运行在一个或几个特定的包上，那么它会监测试图转到其它包的操作，并对其进行阻止。&lt;/li&gt;
  &lt;li&gt;如果应用程序崩溃或接收到任何失控异常，Monkey将停止并报错。&lt;/li&gt;
  &lt;li&gt;如果应用程序产生了应用程序不响应(application not responding)的错误，Monkey将会停止并报错。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;使用流程&lt;/h3&gt;

&lt;p&gt;总的来说使用monkey进行测试是比较简单的，只是需要做一些比较复杂的准备工作，比如配置ADB环境。&lt;br /&gt;
* ADB连接Android测试设备&lt;br /&gt;
* 确定你要测试的应用的PackageName&lt;br /&gt;
* 使用Monkey发一条测试命令&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;spoon&quot;&gt;2．Spoon自动化兼容性测试工具&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    android众多的版本和机型给android app测试工作带来不小的挑战。Spoon通过将case分布式地执行、将执行结果更友好地展示出来，从而简化android app的测试工作。
    Spoon没有开发新的测试框架，而是让已经存在的测试框架更有效。现在的测试框架，一般都是通过测试apk来驱动被测apk，Spoon可以让这些case在多台设备上同时运行。一旦测试结束，Spoon就是生成一份html报表，来展示每台设备上的执行结果。
    Spoon会检测到adb devices命令中显示的全部设备，并在这些设备上执行case。所以我们在使用spoon时，可以插入不同的手机、平板、或者不同配置的模拟器。
    插入的设备越多、越杂，那么最终的测试结果展示的信息就越多。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;截图&lt;/h3&gt;

&lt;p&gt;除了单纯地跑case，Spoon还可以在case执行中，进行截图，并在结果中进行展示。在最后的结果中，我们可以看到不同设备跑一个case时的截图，来测试app的兼容性。&lt;br /&gt;
使用Spoon的截图功能，必须在被测app中引入spoon-clientjar包，在我们的测试代码中调用screenshot方法进行截图，这些截图会被打上标签。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    Spoon.screenshot(activity, &quot;initial_state&quot;);    //这里编写登陆代码    
    Spoon.screenshot(activity, &quot;after_login&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码里指定的tag用来命名截图，以便在测试兼容性的时候进行不同设备间的横向比较。&lt;br /&gt;
我们也可以连贯地浏览每台设备上的截图，来查看运行过程。&lt;br /&gt;
### 下载&lt;br /&gt;
下载最新的runner jar包或者最新的client jar包，或者通过maven来获取：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;    &amp;lt;dependency&amp;gt;   
    &amp;lt;groupId&amp;gt;com.squareup.spoon&amp;lt;/groupId&amp;gt;    
    &amp;lt;artifactId&amp;gt;spoon-client&amp;lt;/artifactId&amp;gt;    
    &amp;lt;version&amp;gt;(insert latest version)&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;执行&lt;/h3&gt;

&lt;p&gt;Spoon既可以单独运行，又可以集成到maven里，作为maven命令的一部分来执行。&lt;br /&gt;
    单独运行，需要被测apk包和测试apk包，执行下面的命令即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;java -jar spoon-runner-1.0.0-jar-with-dependencies.jar  --apk example-app.apk  --test-apk example-tests.apk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果，默认会放在当前目录的spoon-output文件夹下。当然还有一些其他的参数，具体如下：&lt;br /&gt;
Options:       &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;–apk               被测apk       &lt;/li&gt;
  &lt;li&gt;–fail-on-failure   Non-zero exit code on failure        &lt;/li&gt;
  &lt;li&gt;–output            结果路径       &lt;/li&gt;
  &lt;li&gt;–sdk               android sdk路径       &lt;/li&gt;
  &lt;li&gt;–test-apk          测试apk       &lt;/li&gt;
  &lt;li&gt;–title             Execution title       &lt;/li&gt;
  &lt;li&gt;–class-name        Test class name to run (fully-qualified)        &lt;/li&gt;
  &lt;li&gt;–method-name       Test method name to run (must also use –class-name)        &lt;/li&gt;
  &lt;li&gt;–no-animations     Disable animated gif generation       &lt;/li&gt;
  &lt;li&gt;–size              Only run test methods annotated by testSize (small, medium, large)       &lt;/li&gt;
  &lt;li&gt;–adb-timeout       Set maximum execution time per test in seconds (10min default)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;selectorchapek-for-android&quot;&gt;3．SelectorChapek for Android插件&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;jdgui-&quot;&gt;4．Jdgui 反编译工具&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    Jdgui是一个图形化工具，用于查看Jar包的源代码，可以和dex2jar在命令行配合使用
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;反编译步骤&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;首先将apk文件，将后缀改为zip，解压，得到其中的classes.dex，它就是java文件编译再通过dx工具打包而成的&lt;/li&gt;
  &lt;li&gt;解压下载的dex2jar，将classes.dex复制到dex2jar.bat所在目录。在命令行下定位到dex2jar.bat所在目录，然后运行&lt;code&gt;dex2jar.bat classes.dex&lt;/code&gt;生成classes.dex.dex2jar.jar&lt;/li&gt;
  &lt;li&gt;在JdGui中打开生成的jar包就可以看到源码了&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;androidfby-&quot;&gt;5．Androidfby 反编译工具&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    相对于上条提到的dex2jar，这是一个图形化的反编译工具，由apk直接生成带有jar的同名目录，然后使用Jdgui查看其源码，如果apk采用了某些加密机制的话，jar中视看不到源码的，这时可以使用命令行的方式（dex2jar)进行尝试。 
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;git-&quot;&gt;6．GIT 版本控制&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    Git是一款免费、开源的`分布式`版本控制系统，用于敏捷高效地处理任何或小或大的项目。分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者机器上都是一个完整的数据库。即使离线，也能继续进行工作。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-7&quot;&gt;部分常用命令&lt;/h3&gt;

&lt;h4 id=&quot;section-8&quot;&gt;查看、添加、提交、删除、找回，重置修改文件&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;git help “command”  # 显示command的help&lt;/li&gt;
  &lt;li&gt;git show            # 显示某次提交的内容 &lt;/li&gt;
  &lt;li&gt;git co  – “file”   # 抛弃工作区修改&lt;/li&gt;
  &lt;li&gt;git co  .           # 抛弃工作区修改&lt;/li&gt;
  &lt;li&gt;git add “file”      # 将工作文件修改提交到本地暂存区&lt;/li&gt;
  &lt;li&gt;git add .           # 将所有修改过的工作文件提交暂存区&lt;/li&gt;
  &lt;li&gt;git rm “file”       # 从版本库中删除文件&lt;/li&gt;
  &lt;li&gt;git rm “file” –cached  # 从版本库中删除文件，但不删除文件&lt;/li&gt;
  &lt;li&gt;git reset “file”    # 从暂存区恢复到工作文件&lt;/li&gt;
  &lt;li&gt;git reset – .      # 从暂存区恢复到工作文件&lt;/li&gt;
  &lt;li&gt;git reset –hard    # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改&lt;/li&gt;
  &lt;li&gt;git revert “$id”    # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象&lt;/li&gt;
  &lt;li&gt;git revert HEAD     # 恢复最后一次提交的状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;diff&quot;&gt;查看文件diff&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;git diff “file”    # 比较当前文件和暂存区文件差异&lt;/li&gt;
  &lt;li&gt;git diff&lt;/li&gt;
  &lt;li&gt;git diff “id1” “id2”   # 比较两次提交之间的差异&lt;/li&gt;
  &lt;li&gt;git diff “branch1”..”branch2” # 在两个分支之间比较 &lt;/li&gt;
  &lt;li&gt;git diff –staged   # 比较暂存区和版本库差异&lt;/li&gt;
  &lt;li&gt;git diff –cached   # 比较暂存区和版本库差异&lt;/li&gt;
  &lt;li&gt;git diff –stat     # 仅仅比较统计信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-9&quot;&gt;查看提交记录&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;git log&lt;/li&gt;
  &lt;li&gt;git log “file”      # 查看该文件每次提交记录&lt;/li&gt;
  &lt;li&gt;git log -p “file”   # 查看每次详细修改内容的diff&lt;/li&gt;
  &lt;li&gt;git log -p -2       # 查看最近两次详细修改内容的diff&lt;/li&gt;
  &lt;li&gt;git log –stat      #查看提交统计信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-10&quot;&gt;远程分支管理&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;git pull                         # 抓取远程仓库所有分支更新并合并到本地&lt;/li&gt;
  &lt;li&gt;git pull –no-ff                 # 抓取远程仓库所有分支更新并合并到本地，不要快进合并&lt;/li&gt;
  &lt;li&gt;git fetch origin                 # 抓取远程仓库更新&lt;/li&gt;
  &lt;li&gt;git merge origin/master          # 将远程主分支合并到本地当前分支&lt;/li&gt;
  &lt;li&gt;git co –track origin/branch     # 跟踪某个远程分支创建相应的本地分支&lt;/li&gt;
  &lt;li&gt;git co -b “local_branch” origin/”remote_branch”  # 基于远程分支创建本地分支，功能同上&lt;/li&gt;
  &lt;li&gt;git push                         # push所有分支&lt;/li&gt;
  &lt;li&gt;git push origin master           # 将本地主分支推到远程主分支&lt;/li&gt;
  &lt;li&gt;git push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)&lt;/li&gt;
  &lt;li&gt;git push origin “local_branch”   # 创建远程分支， origin是远程仓库名&lt;/li&gt;
  &lt;li&gt;git push origin “local_branch”:”remote_branch”  # 创建远程分支&lt;/li&gt;
  &lt;li&gt;git push origin :”remote_branch”  #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支&lt;/branch&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-11&quot;&gt;优点&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;     适合分布式开发，强调个体。公共服务器压力和数据量都不会太大。速度快、灵活。任意两个开发者之间可以很容易的解决冲突。离线工作。 ### 缺点

    资料少（起码中文资料很少）。学习周期相对而言比较长。不符合常规思维。代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;svn-&quot;&gt;7．SVN 版本控制&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;SVN是Subversion的简称，是一个开放源代码的`集中式`版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion。
集中式代码管理的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上可以说是无法工作的。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-12&quot;&gt;优点&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;管理方便，逻辑明确，符合一般人思维习惯。易于管理，集中式服务器更能保证安全性。代码一致性非常高。适合开发人数不多的项目开发。大部分软件配置管理的大学教材都是使用svn和vss。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-13&quot;&gt;缺点&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;服务器压力太大，数据库容量暴增。如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-14&quot;&gt;二、游戏测评&lt;/h1&gt;

&lt;h2 id=&quot;section-15&quot;&gt;《部落冲突》&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;《部落冲突》（部落战争）是为芬兰游戏公司Supercell所推出的策略类手机游戏，于2012年8月2日在苹果应用商店发布。该游戏以策略战争为主题，通过经营自己的村庄，玩家可逐渐强大兵力，进而成千上万的玩家进行战斗。村庄到达一定等级后，还可与其他村庄结成部落，进行部落间的战斗。其内容兼具攻、守城及养成元素，玩家于一开始时只有“建筑工人小屋”及各一座等级1的“大本营”、“金矿”、“兵营”以及各750点的“圣水”和“黄金”，第一次进入游戏会进入引导模式让玩家了解此游戏的建造、升级、提速及解锁的方式。随着游戏的进行，到了后期重心将会由单人模式移至多人模式。 2013年9月30日该游戏的安卓版在芬兰和加拿大率先推出，2013年10月7日Supercell在世界其他国家的 Google Play市场推出了该游戏。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;q&quot;&gt;富有传奇色彩的人物设计：Q版却不失大气！&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;COC第一个出场的典型角色屌丝兵野蛮人是很多人一开始喜欢用的士兵，也是小编最喜爱的一个角色，他们淌着口水，挥舞着发光的剑刃，不畏惧战火，在部落里奔跑抢夺着，那画面实在是太萌，太讨人喜欢；哥布林身手最快，抢钱最拿手，但也死得也快，一开始我还没有学会活用这个类型的士兵，直到后面有一次认真一用，才发现，升本的资源全靠他啊！巨人是最耐用的炮灰，虽然觉得让自己的士兵去挡枪口这种事太残忍，可每一次攻击都少不了他，没有他，战斗的胜算率基本等于零啊；还有天使胖子和杀伤力极强的龙，这两个飞在天上的，带出去打战就拉风得不得了有木有，以及会使用魔法攻击的法师，简直是守城的心头好！
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-16&quot;&gt;丰富的策略性：每个人都是军事家&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;来到COC后，每个人都懂得摆阵设陷阱了，都懂得攻陷地方的弱点，都会装饰自己的领土了，在COC中，简直是人才济济！加农炮、箭塔、法师塔……这些都是和部落生死存亡性命攸关的家伙，一有金钱就将它们升级到最强，虽然耗费时间，但也乐在其中。最关键的还是大本营，是整个部落的实力和地位的体现。但是升大本营也是最虐心的，忘不了以前为了凑足200万升本，打到100多万时又怕被人抢，因此玩到深夜迟迟不下线，最终凑够200万心满意足升级了，时间已经从凌晨2点走到3点……
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-17&quot;&gt;游戏画面和战斗特效：赞！&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;说起COC,你第一个想到的是什么颜色呢？我想到的是金黄色，因为最喜欢的野蛮小人是金黄金黄的，飞龙喷出的火也是金黄金黄的，以及金子也是金黄金黄的，因此，COC的画面给我的感觉就是暖，和多彩。铿锵铿锵、砰轰砰轰，咻刷咻咻刷……刀剑砍墙的声音，大炮轰鸣的声音，以及弓箭飞驰的声音，COC中的音效和画面都非常到位，每个神力战士的技能也是炫酷到不行。还有一点让小编很喜欢的是，虽然每一场战争都可能有几十个几百个战士死亡，但是游戏丝毫没有血腥的感觉，战士们也多死得很安详，结束战争后，回到部落又能看到他们啦！因此，这款游戏，给我的感觉始终是愉快温暖的。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-18&quot;&gt;因为是第一个 所以经典&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;开发商Supercell带来了Clash of Clans《部落战争》这款新鲜血液之后，它的创新让许多玩家和厂商眼前一亮， 随后也有不少“仿制品”推出，但几乎没有一款能够脱颖而出，玩家们心中最珍爱的还是COC.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-19&quot;&gt;玩家人格魅力的体现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;人组成了一个部落，部落组成了一个世界，部落间的战争是人与人的战争，因此每一场COC的战斗中，都是个人魅力的体现。你的部落的排阵反应了你的个人策略；你的战斗习惯反应了你的心智，一个从来不复仇的人和一个有仇必报的人，在心智上必定有所不同；你的武器和部落的繁荣程度反应了你的消费程度和时间的使用习惯。因此，COC给我的感觉是热闹的，一个热热闹闹的充满人性的微型世界。
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;mt&quot;&gt;《我叫mt》&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;《我叫MT》是以“我叫MT”动画片为素材改编的第一款iOS平台上的卡牌社交网游，是根据同名动漫《我叫MT》改编而成的卡牌养成类手机网游。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-20&quot;&gt;画面&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;游戏的画面怎么说呢，与其去评论画面不如说这款游戏没什么画面。卡牌游戏你还想怎样？不过游戏中的UI设计很有魔兽的风格，让玩家即时再简单的游戏中也能够体会到原来的那种激情。另一个值得一提的就是他的怪物设定，游戏中的怪物除了动画中出现的还有很多开发商后来加入的怪物，风格与原作相差无几。虽然不知道他们是谁但是也可以看得出游戏的用心程度。
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;游戏用卡通的风格来演绎魔兽的画面，针对目标用户而做。画面质量在同类产品中处于上等，无论是场景的画质、卡牌的绘制质量，以及一些UE界面的描边；&lt;/li&gt;
  &lt;li&gt;战斗效果强于同类卡牌手机游戏产品，在6V6的战斗中，卡牌有移动效果、技能效果、打击受击动作，再伴随简单的音效、恰好的战斗节奏，带来的战斗爽快感、 可观赏性非常不错的，玩家在战斗中可以清楚地看到每一次打击、防御、治疗，可以帮助玩家选择战斗策略；&lt;/li&gt;
  &lt;li&gt;操作：竖版的界面设计降低了操作负担。在手握手机的情况下，只依靠大拇.指就能完成大多数的操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-21&quot;&gt;核心玩法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    以收集卡牌、组合卡牌、升级卡牌为核心乐趣，但在卡牌属性中，参照了魔兽世界以及动画片《我叫MT》的角色性格、职业特点，对于魔兽世界玩家或看过动画 片观众，可以轻松地在游戏里找到合适的策略，感受到游戏的乐趣所在。游戏中的卡牌分为《我是MT》动漫角色和非动漫角色，不同的卡片分类，拥有不同的成长 线，卡片可提升的品质等级不一样。其中来源于动漫角色的卡牌名字运用魔兽世界角色职业的音译，并且对名字做了有趣的改变。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-22&quot;&gt;游戏追求&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;收集卡牌之后就要去打FB，杀BOSS了，在战斗中我们会收集到金币、卡牌以及升级所需要装备。社交也是网络游戏的重点，玩家在战斗开始前可以邀请一名好陌生人来助阵，在结束战斗后可以加他为好友，这是建立交流的一个很好的方式
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;PVE方面对玩家实力规划区分做得比较好。PVE方面分为普通难度、精英难度、英雄难度，难度越高，获得的收益呈倍数增长，可以省去非常多的反复刷图时间，即达成花钱省时间的目标&lt;/li&gt;
  &lt;li&gt;游戏副本战斗前要求玩家选择一名玩家协助，战斗结束后可以添加这名玩家为好友，从而为玩家创造了一个建立新关系的的机会，玩家一方面可以在战斗中因为帮助 而胜利，也会因此获得友情点，而这个友情点也可用于抽奖。原版本缺乏竞技性的PVP元素，但是在即将推出的2.0版本将推出PVP竞技场，与副本设计相 似，游戏在竞技场的设计也会有难度区分，帮助不同级别的玩家找到游戏中竞技的乐趣。&lt;/li&gt;
  &lt;li&gt;游戏的攻略系统中提供了英雄图鉴、套装收集和攻略，从这些地方可以获得卡牌、装备以及游戏的有用信息，英雄图鉴中玩家可以查阅每一个卡牌的属性、技能以及获得方式，套装收集中则将拥有套装的数量，套装适用的英雄，套装的来源清晰地展现了出来。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-23&quot;&gt;游戏节奏&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;体力值恢复、定时副本是官方对玩家节奏控制的核心点，这两项设定确保了玩家对游戏有持续回访和关注的需求&lt;/li&gt;
  &lt;li&gt;在卡牌等级升级方面，通过套装收集、活动副本等方式，保证了卡牌升级具有阶梯性&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-24&quot;&gt;《刀塔传奇》&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;     这款游戏以DotA为蓝本，在卡牌游戏中加入了微操作的玩法，让玩家体验到了与众不同的游戏快感。因此，自从今年三月份上线之后，《刀塔传奇》的表现一直不俗：不仅赢得了众多玩家的心，更是一直包揽各大热门手游排行榜的榜首之位，还有媒体称它为“2014年不容错过的动作卡牌游戏”。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-25&quot;&gt;玩法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;《刀塔传奇》的玩法特别突出DotA中的团队配合，玩家在搭配出战英雄队形的时候要考虑到哪几个英雄的组合可以将战队的战斗力提升到最优，这样也在无形之中增加了游戏的策略性。相比起以前的只能干看着傻等的卡牌游戏而言，《刀塔传奇》整个游戏玩下来让玩家觉得自己对战斗的结果有更大的掌控权和主动性。游戏以推图副本为主，玩家组建战队后就会被引导进行战斗。每场战斗分为三小关，每关的时间限制为1.5分钟，战队中的英雄在被攻击时会积攒怒气值，积满怒气值之后就可以手动点击英雄释放必杀技。
值得一提的是，游戏的必杀技特效制作得特别的精美，在战斗的过程中玩家可以有真实的代入感；比如船长的必杀技就是一艘全屏的大船碾压过敌方战队并造成眩晕。令人赞叹的不仅是战斗中技能释放的逼真感，同时还有游戏内容的丰富性。当你对打副本战役感到厌倦的时候，游戏还提供了许多调剂的空间，还可以选择竞技场挑战PVP玩家、可以去时光之穴打宝箱、还可以去做燃烧的远征任务等等。在一次次的战斗中不断地收集英雄，组建更强力的战队，这个过程真的是其乐无穷；同时，游戏中不时出现的卖萌文案也总能博人一笑，成为让玩家爱不释手的一大亮点。
可以说，《刀塔传奇》出现之前，市场上并没有让人眼前一亮的加入微操作元素的卡牌游戏，这是这款游戏在玩法上最大的特色，也是它为何一直在排行榜上立于不败之地的重要原因。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-26&quot;&gt;画面&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;好的玩法搭配优质的画面，也是《刀塔传奇》的一大成功之处。游戏以Q版画风为主，每一幅地图场景、甚至战斗的场景都设计得相当精细；而作为一款卡牌游戏 ，《刀塔传奇》的每张英雄卡牌都刻画得相当用心，每一张卡牌的辨识度都很高、非常有特点，不会因为卡牌总数量太多而淹没在茫茫的卡牌海洋之中。基本上，你可以毫不费力地在英雄列表中一眼看出自己喜欢的英雄。《刀塔传奇》由于与DotA有着千丝万缕的关系，所以在画面和场景上也会让DotA玩家倍感亲切。另外，游戏中的每个英雄除了Q版的可爱形象之外还有一幅原画，点击英雄头像的时候可以展开到整个屏幕，让不少收集控大呼过瘾。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-27&quot;&gt;音效&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;在音效方面，总体可以打四颗星—《刀塔传奇》请了一大票明星来助阵为游戏里的英雄角色配音：比如巨乳女神柳岩来为火女配音，帅模特爸爸张亮为全能骑士配音，歌手胡夏为沉默配音等等；所以它标榜自己为 “最声动卡牌手游”也不为过。另外，游戏的主旋律也是比较激动人心的快节奏旋律，让人听起来就有想要开始战斗的激情。美中不足的是，游戏的其他音效做得比较一般，中规中矩得让人玩过之后并没有留下太大的印象。但作为一款主打战斗和策略的卡牌游戏，《刀塔传奇》的音效表现也算是不错了。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-28&quot;&gt;操作&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;就操作而言，《刀塔传奇》非常有特色。在英雄战斗的时候，玩家不会再扮演一个只能在旁边干瞪眼的旁观者，而是在战斗开始之时就要时时留意英雄们的怒气值，在怒气值满的时候迅速释放技能。并且由于有的英雄有打断技能，所以在恰当的时间释放技能往往成为影响整个战局的关键。不过在操作上，《刀塔传奇》并不是一款复杂的游戏，相反，可以说这是一款在操作上十分便捷的游戏。玩家只需要在相应英雄怒气值满的时候释放技能即可，游戏设置在再次进入已经通关的关卡时可以选择自动战斗，减少了玩家大量重复操作产生的枯燥感；甚至在PVP竞技场中系统被设定成为自动战斗模式，全面考验玩家在战前对队伍整体战斗力的运筹帷幄，而远征中的战斗也让每一个辛苦培养出来的英雄都得以彰显价值和发挥作用。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-29&quot;&gt;收费&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;《刀塔传奇》在苹果商店中国区目前可以免费下载，游戏中会有购买月卡、充值VIP、购买礼包等内购的内容。不过即使不是RMB战士，也还是有机会通过时间、积累跨过各种消费门槛。得益于游戏中相对平衡的数值设定和丰富精彩的玩法内容，各个阶层的玩家都能找到属于自己的乐趣，轻松享受游戏，没有任何负担。
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;deemo&quot;&gt;《Deemo》（《古树旋律》）&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;一直以来认为音乐游戏应该分为两派。一派是追求华丽谱面和复杂判定形式的快感系，多以电音、舞曲为主，而另一派应该是注重意境氛围的乐感系，多以情绪化的小编制室内乐为主。近年来国内音乐游戏市场多半发展得大同小异，可喜的是素有“华人之光”之称的雷亚公司坚持原创的道路，在Cytus获得不俗的成绩后，近日推出新系列的文艺范音乐游戏《Deemo》，这个满满钢琴乐感的纯正音乐游戏也打破了华人音乐游戏缺乏剧情内涵的惯例。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-30&quot;&gt;概述我见：朴实包装下浓浓的音乐呈现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;《Deemo》以优秀的编曲、强烈的氛围营造、弹奏感十足的钢琴模拟，汇聚成一款醇正浓郁的音乐游戏。但另一方面来说其又是不成熟的，过于朴实的谱面设计、过于追求乐感的判定，过于单调的操作体系,对于当下普遍“注重其表”的玩家来说，显然不够讨喜。但这个敢于以异类姿态出现的家伙，不仅仅是一个简单的游戏，它也可以是：音乐而已。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-31&quot;&gt;外在表现：简约勾勒间满满的氛围表现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;在这个时代，游戏表现力不断在刷新突破着极限，而有一种风格却历经时代洗礼依然璀璨耀眼，便是被美誉为“寄宿了作者灵魂”的手绘展现。这种基于人类情感表达使动下而萌生的艺术行为，富含着高超的情绪表现力，往往在看似简约的线条之间，蕴含着深不可测的另一个世界。《Deemo》正是选择了这样符合音乐渲染效果的表现方式，营造出强烈的共鸣画面。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-32&quot;&gt;最刺骨的孤独&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;从天而降的少女打破了钢琴家的宁静，却让光明照亮了这片幽禁之地
游戏在纯手绘风格加上柔和的光源渲染下烘托出教人辛酸的孤独。当玩家投入到主角Deemo的情感中去，随着游戏进展慢慢接近与天降之物离别的终途..就会发现，在充满生机的画面背后，始终埋藏着Deemo那份无法背弃的孤独。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-33&quot;&gt;最揪心的归宿&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;而游戏的另一项表现特色就是随着剧情进展而出现的彩铅风格过场。和主基调的水粉画不同，彩铅勾勒出的过场少了几分忧郁和迷茫，多了更多的愉悦和童话色彩的欢乐张扬…这种反差强烈的过场形式能进一步让玩家投入到游戏的氛围中去，从而在毫无戒备的情况下走向最揪心的归宿。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-34&quot;&gt;最伤感的领悟&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;自从DJ MAX广为人知后，同类音乐游戏的选曲便脱离不了仿CD封面的单曲插画表现形式了。这点上《Deemo》并没有突破，但值得一提的是该游戏中所设计的封面效果不仅和歌曲本身风格十分切合，同时还具备了极强的张力，其中蕴含冷冽的伤感情怀，玩家只要投入足够的想象就能领悟。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-35&quot;&gt;最华丽的礼物&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;《Deemo》为玩家筹备了相当华丽的音乐阵容，不仅有着Mili、M2U等从Cytus就开始备受关注的御用制作人的精心打造，V•K、植松伸夫等知名作曲家的倾力加盟更是极大地拔高了该作的水准高度。多元化的BGM都是中毒性满满的好物，对于一个杂食的音乐控玩家来说，该作是富含新世纪音乐色彩的最佳礼物。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-36&quot;&gt;内涵理念：童话故事后深刻的亲情体现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;《Deemo》的故事是塑造得非常棒的，从表里两个深度来看具备了完全不同的内涵体现。表面上看，这是充满稚趣色彩的童话情节，孤独的Deemo在钢琴的陪伴下静度着岁月，从头而降的少女打破了平静，也给了他从所未有的温馨体验..而快乐的时光总要终结，Deemo最终仍旧用钢琴唤醒沉睡的古树，将少女送回原来的世界…回归孤独，唯有再次响起的钢琴声证明了曾发生过的一切
而深入的从各方面剖析来看，不难了解这讲述的其实是一个关于亲情的故事。歌曲 “Dream”中途出现的杂乱声预示着少女遭遇了灾祸处在生死边缘，而慢慢陷入了沉眠，降临了Deemo的世界。而Deemo正是她逝世的父亲，伴随着戴着面具的母亲一起在冥府中守望着永恒的长夜。女儿的到来打破了宁静，母亲希望留下她慰藉孤独已久的心灵..可女儿憧憬着回归美好的生命..在复杂情感的抉择中，Deemo做出了一个父亲的决定，亲手奏响苏生的钢琴曲，一步步将女儿还给了光明彼方的生命…而那些美好共奏的诗篇，将烙印在两个世界彼此的心灵
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-37&quot;&gt;特色提炼：黑白键盘上盛放的心灵盛宴&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;《Deemo》是一款自始至终注重意境表现的音乐游戏，如同岁乐纪一般。不论是追求乐感的极致表现、还是细致入微的氛围呈现，在黑白分明的键盘式演奏中，都给予人波涛汹涌的心灵震撼。
和通常音乐游戏拥有完善且华丽的操作体验不同，《Deemo》仅有着简单的音符下落、和连续音符滑动两种操纵方式需要留意。在判定上也是以金、绿、蓝三色分别代表perfect、great、miss来简单代过。
令人意外的是，极其简单的操作却衍生了非同寻常的乐感，尤其是实际操作过程中强烈的钢琴演奏手感（=-=需亲身体会）让人惊叹。在游戏过程中以一个称职钢琴伴奏员的身份代入游戏中去，更易在满天袭来的音符中坐怀不乱；一味对着线和音符狂掐死按，成绩通常都会很惨。很显然，比起眼疾手快的目押，这游戏更需要的是乐感。
游戏中的诸多细节设定也为烘托氛围贡献了巨大的助力。在几首歌后就会出现类似“家”的房间，除了给玩家带来些许温馨的对话场面填充剧情外，过场鉴赏模式、隐藏歌曲搜索、以及扩充音乐DLC包的购买下载功能也巧妙地通过设计集成在场景元件内。
而作为游戏主场景存在的古树琴台，也设置了顺应剧情进展而产生变化的对话内容。除了为游戏角色增添更多人性化表现外，也在其中铺设交代了剧情悬念的分析细节。与房间类似的是，该场景下依旧存在可触发反应的元件部位，厂商在细节雕琢上的用心可见一斑。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-38&quot;&gt;一些不足&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;综合整体来看，《Deemo》是一款优秀的音乐游戏，它已经超出吾辈最初的预期，但同时不得不承认在某些点上，其确实难以让所有人都满意，因此它的问世必然引来观点对立的争议。
创新是一柄双刃剑。没有界定判定区的操作体验可以算作是雷亚的创新。这种做法一方面极大地优化了玩家游玩时候的真实演奏体验，但同时也极大的破坏了游戏的丰富度，对于那些视华丽谱面和复杂操作为最大乐趣的玩家来说，这种忠于乐感的设定显得过于平淡无味，感受不到乐趣。
商业是一种黑哲学。《Deemo》中的音乐非常耐听，并且风格多变。有跌宕氛围、有诡异宗教、着毒性电音、也有古朴典雅…但仔细倾听却不难发现它们的通病。这些音乐低频下潜不足显得轰头、中频人声距离处理不当容易影响器乐声场、高频毛刺颇多并且存在齿音情况…这样的效果显得太过混杂，解析力不足更不要提呈像化..实际上某菌研究了网上有人放出的原声音乐提取包后，发觉这些160kps码率MP3构成的音质显然算不上无损转制，很明显Hifi级别的音质必须期待厂商惯例发行OST原声集才是
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 27 Feb 2015 17:45:00 +0800</pubDate>
        <link>/2015/02/27/meizimianshibeiwang/</link>
        <guid isPermaLink="true">/2015/02/27/meizimianshibeiwang/</guid>
        
        
        <category>other</category>
        
      </item>
    
      <item>
        <title>cocos+lua 最佳实践</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#cclua&quot;&gt;第一层：纯C环境下，把C函数注册进Lua环境&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cocos2d-xclua&quot;&gt;第二层：在cocos2d-x环境下，把C函数注册进Lua环境&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#toluac&quot;&gt;第三层：了解为什么要使用toLua++来注册C++类&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ctoluaclua&quot;&gt;第四层：在纯C++环境下，使用toLua++来把一个C++类注册进Lua环境&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cocos2d-xclua-1&quot;&gt;第五层：使用cocos2d-x的方式来将C++类注册进Lua环境&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于cocos2d-x下Lua调用C++的文档看了不少，但没有一篇真正把这事给讲明白了，我自己也是个初学者，摸索了半天，总结如下：&lt;/p&gt;

&lt;p&gt;cocos2d-x下Lua调用C++这事之所以看起来这么复杂、网上所有的文档都没讲清楚，是因为存在5个层面的知识点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在纯C环境下，把C函数注册进Lua环境，理解Lua和C之间可以互相调用的本质&lt;/li&gt;
  &lt;li&gt;在cocos2d-x项目里，把纯C函数注册进Lua环境，理解cocos2d-x是怎样创建Lua环境的、以及怎样得到这个环境并继续自定义它 &lt;/li&gt;
  &lt;li&gt;了解为什么要使用toLua++来注册C++类&lt;/li&gt;
  &lt;li&gt;在纯C++环境下，使用toLua++来把一个C++类注册进Lua环境，理解toLua++的用法 5、在cocos2d-x项目里，使用cocos2d-x注册自身的方式把自定义的C++类注册进Lua环境，理解cocos2d-x是怎样通过bindings-generator脚本来封装toLua++的用法来节省工作量的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;只有理解了前4层，在最后使用bindings-generator脚本的时候心里才会清清楚楚。而网上的文档，要么是只解释了第1层，要么是只填鸭式地告诉你第5层怎么用bindings-generator脚本，不仅中间重要的知识点一概不提，示例代码往往也写的不够简洁，这让我这种看见C++就眼晕的人理解起来大为头疼（不是我不会C++，而是我非常不接受C++的设计哲学，能避就避）。所以接下来的讲解我会对每一层知识点逐一讲解，示例代码也不求完整严谨，而是尽量用最简洁的方式把程序的关键点说明白。&lt;/p&gt;

&lt;h2 id=&quot;cclua&quot;&gt;第一层：纯C环境下，把C函数注册进Lua环境&lt;/h2&gt;

&lt;p&gt;直接看代码比啰哩啰嗦讲一大堆概念要清晰明了的多。建立一个a.lua和一个a.c文件，内容如下，一看就明白是怎么回事了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-lua&quot;&gt;--a.lua
print(foo(99))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;//a.c

#include &amp;lt;lua.h&amp;gt;
#include &amp;lt;lualib.h&amp;gt;
#include &amp;lt;lauxlib.h&amp;gt;

int foo(lua_State *L)
{
  int n = lua_tonumber(L, 1);

  lua_pushnumber(L, n + 1);

  return 1;
}

int main()
{
  lua_State *L = lua_open();

  luaL_openlibs(L);

  lua_register(L, &quot;foo&quot;, foo);

  luaL_dofile(L, &quot;a.lua&quot;);

  lua_close(L);

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;怎么样，这代码简单吧？一看就明白，简单的不能再简单了。我特别烦示例代码里又是判断错误又是加代码注释的，本来看自己不会的代码就够吃力的了，还加那么多花花绿绿的干扰项，纯粹增加学习负担。&lt;br /&gt;
在命令行下用gcc来编译并执行吧：&lt;br /&gt;
&lt;code&gt;
gcc a.c -llua &amp;amp;&amp;amp; ./a.out
&lt;/code&gt;&lt;br /&gt;
注意-llua选项是必要的，因为要连接lua的库。&lt;/p&gt;

&lt;p&gt;看完上面那段代码，再解释起来就容易多了：&lt;/p&gt;

&lt;p&gt;1、要想注册进Lua环境，函数需要定义为这个样：int xxx(lua_State *L)&lt;br /&gt;
2、使用lua_tonumber、lua_tostring等函数，来取得传入的参数，比如lua_tonumber(L, 1)就是得到传入的第一个参数，且类型为数字&lt;br /&gt;
3、使用lua_pushnumber、lua_pushstring等函数，来将返回值压入Lua的环境中，因为Lua支持函数返回多个值，所以可以push多个返回值进Lua环境&lt;br /&gt;
4、最终函数返回的数字表示有多少个返回值被压入了Lua环境 5、使用lua_register宏定义来将这个函数注册进Lua环境，Lua脚本里就可以用它了，大功告成！就这么简单！&lt;/p&gt;

&lt;h2 id=&quot;cocos2d-xclua&quot;&gt;第二层：在cocos2d-x环境下，把C函数注册进Lua环境&lt;/h2&gt;

&lt;p&gt;也简单：&lt;/p&gt;

&lt;p&gt;1、在frameworks/runtime-src/Classes/目录下，找到AppDelegate.cpp文件。如果frameworks目录不存在，则需要参考这篇Blog：用Cocos Code IDE写Lua，如何与项目中的C++代码和谐相处&lt;/p&gt;

&lt;p&gt;AppDelegate.cpp文件中的关键代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;auto engine = LuaEngine::getInstance();
ScriptEngineManager::getInstance()-&amp;gt;setScriptEngine(engine);

LuaStack* stack = engine-&amp;gt;getLuaStack();
stack-&amp;gt;setXXTEAKeyAndSign(&quot;2dxLua&quot;, strlen(&quot;2dxLua&quot;), &quot;XXTEA&quot;, strlen(&quot;XXTEA&quot;));

//register custom function
//LuaStack* stack = engine-&amp;gt;getLuaStack();
//register_custom_function(stack-&amp;gt;getLuaState());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到cocos2d-x已经为我们留出了注册自定义C函数的位置，在注释代码后面这么写就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;lua_State *L = stack-&amp;gt;getLuaState()；
lua_register(L, &quot;test_lua_bind&quot;, test_lua_bind);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以通过ScriptEngineManager类从头取得当前的LuaEngine对象，然后再getLuaStack()方法得到封装的LuaStack对象，再调用getLuaState()得到原始的lua_State结构指针。只要知道了入口位置，其他一切就不成问题了，还是挺简单的。&lt;/p&gt;

&lt;p&gt;感兴趣的话可以去看一下ScriptEngineManager类的详细定义，在frameworks/cocos2d-x/cocos/base/CCScriptSupport.h文件中。&lt;/p&gt;

&lt;p&gt;BTW：这里还有一个小知识点，插入在AppDelegate.cpp中的自定义代码尽量写在COCOS2D_DEBUG宏定义的判断前面，因为在调试环境下和真机环境下后续执行的代码是不一样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#if (COCOS2D_DEBUG&amp;gt;0)
    if (startRuntime())
        return true;
#endif

    // 调试环境下代码就不会走到这里了
    engine-&amp;gt;executeScriptFile(ConfigParser::getInstance()-&amp;gt;getEntryFile().c_str());
    return true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、接下来，找个地方把test_lua_bind函数定义写进去就算大功告成了。如果追求文件组织的优雅，按理说应该新建一个.c文件，但这样的话搞不好会把自己陷入到编译阶段的泥潭里，所以先不追求优雅，而就在AppDelegate.cpp文件末尾写上函数的定义就可以了，简单清楚明了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;int test_lua_bind(lua_State *L)
{
    int number = lua_tonumber(L, 1);

    number = number + 1;

    lua_pushnumber(L, number);

    return 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、大功告成，现在就可以在main.lua文件里使用test_lua_bind()函数了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-lua&quot;&gt;  local i = test_lua_bind(99)
  print(&quot;lua bind: &quot; .. tostring(i))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、如果是新建一个.c文件呢？把AppDelegate.cpp文件里test_lua_bind函数定义的代码删掉，在头部#include后面加入：&lt;br /&gt;
&lt;code&gt;#include &quot;test_lua_bind.h&quot;&lt;/code&gt;&lt;br /&gt;
在frameworks/runtime-src/Classes目录下创建test_lua_bind.h文件，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;extern &quot;C&quot; {
#include &quot;lua.h&quot;
#include &quot;lualib.h&quot;
}

int test_lua_bind(lua_State *L);
再创建test_lua_bind.c文件，内容不变：

#include &quot;test_lua_bind.h&quot;

int test_lua_bind(lua_State *L)
{
    int number = lua_tonumber(L, 1);

    number = number + 1;

    lua_pushnumber(L, number);

    return 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时用&lt;code&gt;cocos compile -p mac&lt;/code&gt;命令编译，会发现test_lua_bind.c文件并没有被编译。这是当然的，普通的C/C++项目都是用Makefile来指定编译哪些.c/cpp文件的，当前的cocos2d-x项目虽然没有Makefile文件，但也是遵循这个原则的，也即肯定是有一个地方来指定所有要编译的文件的，需要在这个地方把test_lua_bind.c加进去，使得整个项目编译时把它也作为项目的一部分。&lt;/p&gt;

&lt;p&gt;答案是，cocos2d-x项目没有使用Makefile，而是非常聪明地使用了与具体环境相关的工程文件来作为命令行编译的环境，比如在编译iOS或Mac时就使用Xcode工程文件，在编译Android时就使用Android.mk文件。&lt;/p&gt;

&lt;p&gt;所以，添加好了test_lua_bind.h和test_lua_bind.c文件后，用Xcode打开项目，将这俩文件添加进工程中就行了。&lt;/p&gt;

&lt;p&gt;Xcode中添加.h和.cpp文件进工程&lt;/p&gt;

&lt;p&gt;注意，千万不要勾选“Copy items into destination group’s folder(if needed)”，因为cocos2d-x的Xcode工程目录组织不是常规的结构，一旦勾选这个，会导致这两个文件被拷贝至frameworks/runtime-src/proj.ios_mac目录下，原来frameworks/runtime-src/Classes目录下的文件就废掉了，这样的组织方式会乱，而且会影响Android那边对这俩文件的引用。&lt;/p&gt;

&lt;p&gt;把test_lua_bind.h和test_lua_bind.cpp这俩文件添加进Xcode工程后，再去命令行执行cocos compile -p mac，编译就能成功了。&lt;/p&gt;

&lt;p&gt;网上有其他文章说还要修改Xcode工程的“User Headers Path”，这个经过试验是不需要的，哪怕把这俩文件放进新建的文件夹里也不需要，只要加入了Xcode工程即可，因为Xcode内部根本就不是按照文件夹的形式来组织文件的，它自己有一套叫做“Group”的东西。搞了好几年iOS开发，对Xcode的这个特性还是熟悉的。&lt;/p&gt;

&lt;p&gt;说到这就不禁要插一句对网上所有cocos2d-x文档的吐槽了，学习cocos2d-x的人水平实在是良莠不齐，大部分人似乎都是对游戏热衷的编程初学者，他们大多底子薄基础差，甚至一大部分人之前都没做过移动APP的开发，他们学习cocos2d-x只想知其然而不想知其所以然，给他们讲他们也看不明白（因为编程基础差），所以网上不少cocos2d-x文章都是只讲123步骤，而不告诉你为什么这么做，包括cocos2d-x官方的大量文档也是基于这个思路写的，中文和英文都一样。我看这些文章就特别痛苦，一边看一边心里就总是在想，“凭什么要这么做啊”、“这一步是为了什么啊”、“怎么这么麻烦啊”、“这个步骤明显不是最佳实践啊”、“解决这事为啥要这么麻烦”、“有更好的方法吗”，所以我这种初学者来看cocos2d-x文档就变成了不是单纯的学习，而是学习、质疑、求证、反思、优化的过程，对别人来说cocos2d-x的入门比较容易，到我这里反倒成了入门比较难、入门之后比较容易了，因为文档中的垃圾信息和无效信息实在是太多了，别人可以照单全收、以后懂了之后再慢慢剔除，我是必须从一开始就自己甄别垃圾、只保留最佳实践，这也是这篇Blog写的比较长的原因。&lt;/p&gt;

&lt;p&gt;扯远了。反正经过以上步骤，就完成了在cocos2d-x项目中把C函数注册进Lua环境这件事。至此，算是彻底搞懂了Lua和C函数之间的互相调用关系，也能在cocos2d-x的Lua环境中使用自定义的C函数了。但这还不够，因为一个正规的项目是需要狠好的组织结构的，全局C函数满天飞肯定是不行的，好一点的情况是把所有的C函数都在Lua中组织为模块注册进去，更好一点的情况是把C++类注册进Lua、并且C++类也是以Lua模块为组织方式注册进Lua环境的。这其实就是cocos2d-x自己把自己注册进Lua环境的方式。&lt;/p&gt;

&lt;h2 id=&quot;toluac&quot;&gt;第三层：了解为什么要使用toLua++来注册C++类&lt;/h2&gt;

&lt;p&gt;因为Lua的本质是C，不是C++，Lua提供给C用的API也都是基于面向过程的C函数来用的，要把C++类注册进Lua形成一个一个的table环境是不太容易一下子办到的事，因为这需要绕着弯地把C++类变成各种其他类型注册进Lua，相当于用面向过程的思维来维护一个面向对象的环境。这其中的细节就不去深究了，总之正是因为如此，所以单纯地手写lua_register()等代码来注册C++类是行不通的、代价高昂的，所以需要借助toLua++这个工具。&lt;/p&gt;

&lt;p&gt;这一层的知识点看似简单，但其实是非常重要的，只有理解了手工用lua_register()去注册C++类的难度，才能理解使用toLua++这类工具的必要性。只有理解了使用toLua++工具的必要性，才会潜下心来冷静地接受toLua++本身的优点和缺点。只有看到了toLua++本身的缺点和使用上的麻烦，才会真心理解cocos2d-x使用bindings-generator脚本带来的好处。只有理解了bindings-generator脚本带来的好处，才能谅解这个脚本本身在使用上的一些不便之处。&lt;/p&gt;

&lt;h2 id=&quot;ctoluaclua&quot;&gt;第四层：在纯C++环境下，使用toLua++来把一个C++类注册进Lua环境&lt;/h2&gt;

&lt;p&gt;虽然终极方法是用bindings-generator脚本来注册C++类进cocos2d-x的Lua环境，但理解toLua++本身的用法还是狠有必要的，只有知道了toLua++原本的用法，才能更好地理解cocos2d-x是怎么把自己的C++类都注册进Lua环境的，这不仅能让编程时的思路更加清晰，也能为日后在源码中寻找各种接口文档的过程中不至于看不懂那一大堆tolua_beginmodule、tolua_function是什么意思。影响程序员学习提高的一大障碍就是忽略那些一知半解的代码，不去刨根究底地搞明白。&lt;/p&gt;

&lt;p&gt;使用toLua++的标准做法是：&lt;/p&gt;

&lt;p&gt;1、准备好自己的C++类，该怎么写就怎么写&lt;br /&gt;
2、仿造这个类的.h文件，改一个.pkg文件出来，具体格式要按照toLua++的规定，比如移除所有的private成员等 3、建一个专门用来桥接C++和Lua之间的C++类，使用特殊的函数签名来写它的.h文件，.cpp文件不写，等着toLua++来生成&lt;br /&gt;
4、给这个桥接的C++类写一个.pkg文件，按照toLua++的特殊格式来写，目的是把真正做事的C++类给定义进去 5、在命令行下用toLua++生成桥接类的.cpp文件&lt;br /&gt;
6、程序入口引用这个桥接类，执行生成的桥接函数，Lua环境中就可以使用真正做事的C++类了&lt;/p&gt;

&lt;p&gt;toLua++这种自己手写.pkg文件的方式古老又难受，所以我没有仔细地去学习，这套流程放在10年前的那个年代是没有太大问题的，作者怎么规定就怎么用好了，但是放在2014年的今天，任何程序的架构设计都讲究学习成本低、轻量化、符合以往的习惯，因此toLua++用起来我觉得其实是难受的。&lt;/p&gt;

&lt;p&gt;下面我以尽量最少的代码来走一遍toLua++的流程，注意这是在纯C++环境下，跟任何框架都没关系，也不考虑内存释放等细节：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;//MyClass.h

class MyClass {
public:
  MyClass() {};

  int foo(int i);
};
MyClass.cpp

#include &quot;MyClass.h&quot;

int MyClass::foo(int i)
{
  return i + 100;
}
MyClass.pkg

class MyClass
{
  MyClass();
  int foo(int i);
};
MyLuaModule.h

extern &quot;C&quot; {
#include &quot;tolua++.h&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include &quot;MyClass.h&quot;

TOLUA_API int tolua_MyLuaModule_open(lua_State* tolua_S);
MyLuaModule.pkg

#include &quot;MyLuaModule.h&quot;

pfile &quot;MyClass.pkg&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;//main.cpp

extern &quot;C&quot; { 
#include &amp;lt;lua.h&amp;gt;
#include &amp;lt;lualib.h&amp;gt;
#include &amp;lt;lauxlib.h&amp;gt;
}

#include &quot;MyLuaModule.h&quot;

int main()
{
  lua_State *L = lua_open();

  luaL_openlibs(L);

  tolua_MyLuaModule_open(L);

  luaL_dofile(L, &quot;main.lua&quot;);

  lua_close(L);

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-lua&quot;&gt;main.lua
local test = MyClass:new()
print(test:foo(99))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先在命令行下执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tolua++ -o MyLuaModule.cpp MyLuaModule.pkg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此命令用来生成桥接文件MyLuaModule.cpp。注意命令行中-o参数的顺序不能随意摆放，从这个小事也能看出tolua++的古老和难用&lt;/p&gt;

&lt;p&gt;生成好MyLuaModule.cpp文件后，就能看到它里面的那一大堆桥接代码了，比如tolua_beginmodule、tolua_function等。以后看到这些东西就不陌生了，就明白这些函数只是toLua++用来做桥接的必备代码了，简单看一下代码，就理解toLua++是怎样把MyClass这个C++类注册进Lua中的了：&lt;/p&gt;

&lt;p&gt;toLua++生成的桥接代码&lt;/p&gt;

&lt;p&gt;接下来，用g++来编译：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;g++ MyClass.cpp MyLuaModule.cpp main.cpp -llua -ltolua++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认就生成了a.out文件，执行，就能看到main.lua的执行结果了：&lt;/p&gt;

&lt;p&gt;toLua++的执行结果&lt;/p&gt;

&lt;p&gt;至此，对toLua++的运作原理心里就透亮了，无非就是：&lt;/p&gt;

&lt;p&gt;1、把自己该写的类写好&lt;br /&gt;
2、写个.pkg文件，告诉toLua++这个类暴露出哪些接口给Lua环境 3、再写个桥接的.h和.pkg文件，让toLua++去生成桥接代码&lt;br /&gt;
4、在程序里使用这个桥接代码，类就注册进Lua环境里了&lt;/p&gt;

&lt;h2 id=&quot;cocos2d-xclua-1&quot;&gt;第五层：使用cocos2d-x的方式来将C++类注册进Lua环境&lt;/h2&gt;

&lt;p&gt;cocos2d-x在2.x版本里就是用toLua++和.pkg文件这么把自己注册进Lua环境里的。不过这种方法明显笨拙，既要写真正做事的.pkg文件，也要写桥接的.pkg文件和.h文件，工作量又大又枯燥。所以从cocos2d-x 3.x开始，用bindings-generator脚本代替了toLua++。&lt;/p&gt;

&lt;p&gt;bindings-generator脚本的工作机制是：&lt;/p&gt;

&lt;p&gt;1、不用挨个类地写桥接.pkg和.h文件了，直接定义一个ini文件，告诉脚本哪些类的哪些方法要暴露出来，注册到Lua环境里的模块名是什么，就行了，等于将原来的每个类乘以3个文件的工作量变成了所有类只需要1个.ini文件&lt;br /&gt;
2、摸清了toLua++工具的生成方法，改由Python脚本动态分析C++类，自动生成桥接的.h和.cpp代码，不调用tolua++命令了 3、虽然不再调用tolua++命令了，但是底层仍然使用toLua++的库函数，比如tolua_function，bindings-generator脚本生成的代码就跟使用toLua++工具生成的几乎一样&lt;/p&gt;

&lt;p&gt;bindings-generator脚本掌握了生成toLua++桥接代码的主动权，不仅可以省下大量的.pkg和.h文件，而且可以更好地插入自定义代码，达到cocos2d-x环境下的一些特殊目的，比如内存回收之类的。所以cocos2d-x从3.x开始放弃了toLua++和.pkg而改用了自己写的bindings-generator脚本是非常值得赞赏的聪明做法。&lt;/p&gt;

&lt;p&gt;接下来说怎么用bindings-generator脚本：&lt;/p&gt;

&lt;p&gt;1、写自己的C++类，按照cocos2d-x的规矩，继承cocos2d::Ref类，以便使用cocos2d-x的内存回收机制。当然不这么干也行，但是不推荐，不然在Lua环境下对象的释放狠麻烦。&lt;br /&gt;
2、编写一个.ini文件，让bindings-generator可以根据这个配置文件知道C++类该怎么暴露出来 3、修改bindings-generator脚本，让它去读取这个.ini文件&lt;br /&gt;
4、执行bindings-generator脚本，生成桥接C++类方法 5、用Xcode将自定义的C++类和生成的桥接文件加入工程，不然编译不到&lt;br /&gt;
6、修改AppDelegate.cpp，执行桥接方法，自定义的C++类就注册进Lua环境里了&lt;/p&gt;

&lt;p&gt;看着步骤挺多，其实都狠简单。下面一步一步来。&lt;/p&gt;

&lt;p&gt;首先是自定义的C++类。我习惯将文件保存在frameworks/runtime-src/Classes/目录下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;//frameworks/runtime-src/Classes/MyClass.h

#include &quot;cocos2d.h&quot;

using namespace cocos2d;

class MyClass : public Ref
{
public:
  MyClass()   {};
  ~MyClass()  {};
  bool init() { return true; };
  CREATE_FUNC(MyClass);

  int foo(int i);
};
frameworks/runtime-src/Classes/MyClass.cpp

#include &quot;MyClass.h&quot;

int MyClass::foo(int i)
{
  return i + 100;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后编写.ini文件。在frameworks/cocos2d-x/tools/tolua/目录下能看到genbindings.py脚本和一大堆.ini文件，这些就是bindings-generator的实际执行环境了。随便找一个内容比较少的.ini文件，复制一份，重新命名为MyClass.ini。大部分内容都可以凑合不需要改，这里仅列出必须要改的重要部分：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;frameworks/cocos2d-x/tools/tolua/MyClass.ini

[MyClass]
prefix           = MyClass
target_namespace = my
headers          = %(cocosdir)s/../runtime-src/Classes/MyClass.h
classes          = MyClass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也即在MyClass.ini中指定MyClass.h文件的位置，指定要暴露出来的类，指定注册进Lua环境的模块名。&lt;/p&gt;

&lt;p&gt;注意，这个地方我踩了个坑。如果.ini配置文件中存在macro_judgement = …宏定义，要特别小心，我第一次是从cocos2dx_controller.ini文件复制来的，结果没注意macro_judgement，导致生成的桥接类文件加入了不该加入的宏，只在iOS和Android平台上才起作用，对Mac平台无效，这个要特别注意。&lt;/p&gt;

&lt;p&gt;然后修改genbindings.py文件129行附近，将MyClass.ini文件加进去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;frameworks/cocos2d-x/tools/tolua/genbindings.py

cmd_args = {&#39;cocos2dx.ini&#39; : (&#39;cocos2d-x&#39;, &#39;lua_cocos2dx_auto&#39;), \
            &#39;MyClass.ini&#39; : (&#39;MyClass&#39;, &#39;lua_MyClass_auto&#39;), \
            ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（其实这一步本来是可以省略的，只要让genbindings.py脚本自动搜寻当前目录下的所有ini文件就行了，不知道将来cocos2d-x团队会不会这样优化）&lt;/p&gt;

&lt;p&gt;至此，生成桥接文件的准备工作就做好了，执行genbindings.py脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python genbindings.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（在Mac系统上可能会遇到缺少yaml、Cheetah包的问题，安装这些Python包狠简单，先sudo easy_install pip，把pip装好，然后用pip各种pip search、sudo pip install就可以了）&lt;/p&gt;

&lt;p&gt;成功执行genbindings.py脚本后，会在frameworks/cocos2d-x/cocos/scripting/lua-bindings/auto/目录下看到新生成的文件：&lt;/p&gt;

&lt;p&gt;成功执行genbindings.py后生成的桥接C++文件&lt;/p&gt;

&lt;p&gt;每次执行genbindings.py脚本时间都挺长的，因为它要重新处理一遍所有的.ini文件，建议大胆修改脚本文件，灵活处理，让它每次只处理需要的.ini文件就可以了，比如像这个样子：&lt;/p&gt;

&lt;p&gt;修改genbindings.py使其只生成自定义的桥接类&lt;/p&gt;

&lt;p&gt;在frameworks/cocos2d-x/cocos/scripting/lua-bindings/auto/目录下观察一下生成的C++桥接文件lua_MyClass_auto.cpp，里面的注册函数名字为register_all_MyClass()，这就是将MyClass类注册进Lua环境的关键函数：&lt;/p&gt;

&lt;p&gt;生成的桥接文件内容&lt;/p&gt;

&lt;p&gt;编辑frameworks/runtime-src/Classes/AppDelegate.cpp文件，首先在文件头加入对lua_MyClass_auto.hpp文件的引用：&lt;/p&gt;

&lt;p&gt;AppDelegate.cpp文件的头加入对lua_MyClass_auto.hpp文件的引用&lt;/p&gt;

&lt;p&gt;然后在正确的代码位置加入对register_all_MyClass函数的调用：&lt;/p&gt;

&lt;p&gt;修改AppDelegate.cpp文件，将MyClass类注册进Lua环境&lt;/p&gt;

&lt;p&gt;最后在执行编译前，将新加入的这几个C++文件都加入到Xcode工程中，使得编译环境知道它们的存在：&lt;/p&gt;

&lt;p&gt;在Xcode中加入新冒出来的C++文件&lt;/p&gt;

&lt;p&gt;这其中还有一个小坑，由于lua_MyClass_auto.cpp文件要引用MyClass.h文件，而这俩文件分属于不同的子项目，互相不认识头文件的搜寻路径，因此需要手工修改一下cocos2d_lua_bindings.xcodeproj子项目的User Header Search Paths配置。特别注意一共有几个../：&lt;/p&gt;

&lt;p&gt;需要修改cocos2d_lua_bindings子项目的User Header Search Paths配置&lt;/p&gt;

&lt;p&gt;最后，就可以用cocos compile -p mac命令重新编译整个项目了，不出意外的话编译一定是成功的。&lt;/p&gt;

&lt;p&gt;修改main.lua文件中，尝试调用一下MyClass类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local test = my.MyClass:create()
print(&quot;lua bind: &quot; .. test:foo(99))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行程序（用cocos rum -p mac或在Cocos Code IDE中均可），见证奇迹的时刻~~~~咦我擦？！程序崩溃！为毛？&lt;/p&gt;

&lt;p&gt;第一次运行绑定了C++类的程序居然崩溃&lt;/p&gt;

&lt;p&gt;这是我作为cocos2d-x初学者遇到的最大的坑，坑了我整整一天半，具体的研究细节就不详细说了，总之罪魁祸首是cocos2d-x框架中的CCLuaEngine.cpp文件的这段代码：&lt;/p&gt;

&lt;p&gt;CCLuaEngine.cpp执行的这段代码要了命了&lt;/p&gt;

&lt;p&gt;原因是executeScriptFile函数执行时，对当前Lua环境中的栈进行了清理，当register_all_MyClass函数被调用时，Lua栈是全空的状态，函数内部执行到tolua_module函数调用时就崩溃了：&lt;/p&gt;

&lt;p&gt;CCLuaEngine.cpp中对executeScriptFile方法的定义清理了Lua栈&lt;/p&gt;

&lt;p&gt;解决办法是修改AppDelegate.cpp为这个样子：&lt;/p&gt;

&lt;p&gt;AppDelegate.cpp调用register_all_MyClass函数时要重新恢复一下栈的内容才行&lt;/p&gt;

&lt;p&gt;文本形式的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;//AppDelegate.cpp

lua_State *L = stack-&amp;gt;getLuaState();
lua_getglobal(L, &quot;_G&quot;);
register_all_MyClass(L);
lua_settop(L, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新编译并执行,程序终于正确执行了&lt;/p&gt;

&lt;p&gt;至此，就彻底搞清楚应该怎样在cocos2d-x项目里绑定一个C函数或者C++类到Lua环境中了，感兴趣的话可以再进一步深入研究Lua内部metatable的运作原理、类对象的生成与释放、以及垃圾回收。我自己也是刚接触cocos2d-x不到一个星期，理解不深，以上难免会有用词不当或理解错误的地方，如有错误请多包涵。&lt;/p&gt;

&lt;p&gt;后记补充：如果C++类定义了namespace，则需要修改frameworks/cocos2d-x/tools/bindings-generator/targets/lua/conversions.yaml文件，定义namespace与Lua之间的映射关系，否则会报conversion wasn’t set错误：&lt;/p&gt;

&lt;p&gt;C++的类如果定义了namespace，则需要在导出Lua时修改conversions.yaml文件&lt;/p&gt;
</description>
        <pubDate>Wed, 21 Jan 2015 18:54:00 +0800</pubDate>
        <link>/2015/01/21/cocos-lua/</link>
        <guid isPermaLink="true">/2015/01/21/cocos-lua/</guid>
        
        
        <category>cocos</category>
        
      </item>
    
      <item>
        <title>Twisted adb模块 api</title>
        <description>&lt;p&gt;#1. Scheduling tasks for the future&lt;br /&gt;
&amp;gt; 要在未来X秒的时候运行一个任务，这种方式定义在reactor接口里面&lt;br /&gt;
``` python&lt;br /&gt;
twisted.internet.interfaces.IReactorTime:&lt;/p&gt;

&lt;p&gt;from twisted.internet import reactor&lt;br /&gt;
def f(s):&lt;br /&gt;
    print “this will run 3.5 seconds after it was scheduled: %s” % s&lt;br /&gt;
reactor.callLater(3.5, f, “hello, world”)&lt;br /&gt;
# f() will only be called if the event loop is started.&lt;br /&gt;
reactor.run()&lt;br /&gt;
&lt;code&gt;
&amp;gt; 如果函数结果很重要或者有必要处理函数抛出的异常，那么twisted.internet.task.deferLater功能可以很方便的创建一个Deferred并设置一个延迟调用： 
&lt;/code&gt; python&lt;br /&gt;
from twisted.internet import task&lt;br /&gt;
from twisted.internet import reactor&lt;br /&gt;
def f(s):&lt;br /&gt;
  return “This will run 3.5 seconds after it was scheduled: %s” % s&lt;br /&gt;
d = task.deferLater(reactor, 3.5, f, “hello, world”)&lt;br /&gt;
def called(result):&lt;br /&gt;
  print result&lt;br /&gt;
d.addCallback(called)&lt;br /&gt;
# f() will only be called if the event loop is started.&lt;br /&gt;
reactor.run()&lt;br /&gt;
&lt;code&gt;
&amp;gt; 如果我们要让一个任务在未来每X秒运行一次，我们可以用twisted.internet.task.LoopingCall: 
&lt;/code&gt; python&lt;br /&gt;
from twisted.internet import task&lt;br /&gt;
from twisted.internet import reactor&lt;br /&gt;
def runEverySecond():&lt;br /&gt;
    print “a second has passed”&lt;br /&gt;
l = task.LoopingCall(runEverySecond)&lt;br /&gt;
l.start(1.0) # call every second&lt;br /&gt;
# l.stop() will stop the looping calls&lt;br /&gt;
reactor.run()&lt;br /&gt;
&lt;code&gt;
&amp;gt; 如果我们要取消一个已经在调度(we have scheduled)的任务（应该是指已经加入调度队列的任务）： 
&lt;/code&gt; python&lt;br /&gt;
from twisted.internet import reactor&lt;br /&gt;
def f():&lt;br /&gt;
    print “I’ll never run.”&lt;br /&gt;
callID = reactor.callLater(5, f)&lt;br /&gt;
callID.cancel()&lt;br /&gt;
reactor.run()&lt;br /&gt;
```&lt;br /&gt;
&amp;gt; 就像所有基于reactor的代码(reactor-based code)一样，为了让调度运行必须启动reactor: reactor.run().&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;#2. twisted.enterprise.adbapi: Twisted RDBMS support&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Twsited是一个异步网络框架，但是不幸的是大部分数据库API的实现都是阻塞接口—鉴于这个原因，twisted.enterprise.adbapi横空出世。它是针对标准 DB-API 2.0 API 的非阻塞接口，而且可以访问许多不同的RDBMSes.&lt;br /&gt;
enterpreise.adbapi会在单独的线程里面执行阻塞的数据库操作，当数据库操作完成的时候又会在原来的线程(originating thread，可能是说twisted的主事件循环线程)中触发回调。在此期间，原来的线程可以继续做正常的工作，比如服务于其他请求。&lt;br /&gt;
我们并非要直接创建数据库连接，而是用adbapi.ConnectionPool类管理数据库连接。这东东允许enterprise.adbapi使用多个数据库连接，每个线程一个。很简单:&lt;br /&gt;
&lt;code&gt;python
# Using the &quot;dbmodule&quot; from the previous example, create a ConnectionPool 
from twisted.enterprise import adbapi 
dbpool = adbapi.ConnectionPool(&quot;dbmodule&quot;, &#39;mydb&#39;, &#39;andrew&#39;, &#39;password&#39;)
&lt;/code&gt;&lt;br /&gt;
需要注意的是：&lt;br /&gt;
不需要直接import dbmodule。只用把module的名字传递给adbapi.ConnectionPool的构造函数就行了。&lt;br /&gt;
需要传递给dbmodule.connect()的参数应当做额外的参数传递给adbapi.ConnectionPool的构造函数。关键字参数也没问题。&lt;br /&gt;
现在我们来做一个数据库查询：&lt;br /&gt;
&lt;code&gt;python
# equivalent of cursor.execute(statement), return cursor.fetchall():
def getAge(user):
  return dbpool.runQuery(&quot;SELECT age FROM users WHERE name = ?&quot;, user)
def printResult(l):
  if l:
    print l[0][0], &quot;years old&quot;
  else:
    print &quot;No such user&quot;
&lt;/code&gt;&lt;br /&gt;
除了getAge的返回值以外，其他都很直观。getAge返回了一个twisted.internet.defer.Deferred,这个Deferred允许在数据库操作完成的时候对于结果或者错误执行任意的callback。&lt;br /&gt;
除了runQuery,还有runOperation和runInteraction可以被调用。The function will be called in the thread with a twisted.enterprise.adbapi.Transaction, which basically mimics a DB-API cursor. 在所有情况下，一个数据库的事务会在这次数据库使用结束的时候提交，除非抛出了异常（如果抛出了异常就会回滚）。&lt;br /&gt;
&lt;code&gt;python
def _getAge(txn, user):
  # this will run in a thread, we can use blocking calls
  txn.execute(&quot;SELECT * FROM foo&quot;)
  # ... other cursor commands called on txn ...
  txn.execute(&quot;SELECT age FROM users WHERE name = ?&quot;, user)
  result = txn.fetchall()
  if result:
    return result[0][0]
  else:
    return None
def getAge(user):
  return dbpool.runInteraction(_getAge, user)
def printResult(age):
  if age != None:
    print age, &quot;years old&quot;
  else:
    print &quot;No such user&quot;
getAge(&quot;joe&quot;).addCallback(printResult)
&lt;/code&gt;&lt;br /&gt;
这里都假定了dbmodule使用”qmark”风格的参数(parmstyle)(参见DB-API说明书)，这是不碍事的。如果我们的dbmodule要使用一种不同的参数风格(比如pyformat),那么直接用就是了。twisted没有试图提供任何类型的魔法参数转换—runQuery(query,aprams,…)直接映射到cursor.execute(query,params,…).&lt;br /&gt;
Examples of various database adapters &lt;br /&gt;
注意，第一个参数是我们要import和使用connect(…)的module的名字，接下来的参数是我们调用connect(…)的参数。&lt;br /&gt;
&lt;code&gt;python
from twisted.enterprise import adbapi
# Gadfly
cp = adbapi.ConnectionPool(&quot;gadfly&quot;, &quot;test&quot;, &quot;/tmp/gadflyDB&quot;)
# PostgreSQL PyPgSQL
cp = adbapi.ConnectionPool(&quot;pyPgSQL.PgSQL&quot;, database=&quot;test&quot;)
# MySQL
cp = adbapi.ConnectionPool(&quot;MySQLdb&quot;, db=&quot;test&quot;)
&lt;/code&gt;&lt;br /&gt;
===================================================================================================================================================================== &lt;br /&gt;
#3. Using Threads in Twisted &amp;amp; Running code in a thread-safe manner &lt;br /&gt;
Twisted中的大部分代码非线程安全。例如，往一个protocol的transport写数据就不是线程安全的。所以，我们需要一种方式来把函数调度到主事件循环里面去运行。这个可用函数twisted.internet.interfaces.IReactorThreads.callFromThread来做到：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from twisted.internet import reactor
def notThreadSafe(x):
   &quot;&quot;&quot;do something that isn&#39;t thread-safe&quot;&quot;&quot;
   # ...
def threadSafeScheduler():
  &quot;&quot;&quot;Run in thread-safe manner.&quot;&quot;&quot;
  reactor.callFromThread(notThreadSafe, 3) # will run &#39;notThreadSafe(3)&#39;
                       # in the event loop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#4. Running code in threads &lt;br /&gt;
&amp;gt; 有时我们需要在线程中运行函数–例如，要访问阻塞的API。twisted用IReactorThreads API(twisted.internet.interfaces.IReactorThreads)提供这种方法。其他的功能性函数在twisted.internet.threads中提供。基本上，这些方法可以让我们把函数排进队列里让线程池运行了。&lt;br /&gt;
例如，要在一个线程中运行一个函数我们可以这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from twisted.internet import reactor
def aSillyBlockingMethod(x):
  import time
  time.sleep(2)
  print x
# run method in thread
reactor.callInThread(aSillyBlockingMethod, &quot;2 seconds have passed&quot;)
reactor.run()
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;功能性函数（utility methods）不是twisted.internet.reactor APIs的一部分，而是在twisted.internet.threads中实现。&lt;br /&gt;
如果我们有多个函数要在一个线程中序列化运行，我们可以这么做：&lt;br /&gt;
&lt;code&gt;python
from twisted.internet import reactor, threads
def aSillyBlockingMethodOne(x):
  import time
  time.sleep(2)
  print x
def aSillyBlockingMethodTwo(x):
  print x
# run both methods sequentially in a thread
commands = [(aSillyBlockingMethodOne, [&quot;Calling First&quot;], {})]
commands.append((aSillyBlockingMethodTwo, [&quot;And the second&quot;], {}))
threads.callMultipleInThread(commands)
reactor.run()
&lt;/code&gt;&lt;br /&gt;
对于我们需要获取其结果的函数，我们可以让结果作为一个Deferred返回：&lt;br /&gt;
&lt;code&gt;python
from twisted.internet import reactor, threads
def doLongCalculation():
  # .... do long calculation here ...
  return 3
def printResult(x):
  print x
# run method in thread and get result as defer.Deferred
d = threads.deferToThread(doLongCalculation)
d.addCallback(printResult)
reactor.run()
&lt;/code&gt;&lt;br /&gt;
如果我们要在reactor线程中调用一个函数并获取它的结果，我们可以用blockingCallFromThread:&lt;br /&gt;
&lt;code&gt;python
from twisted.internet import threads, reactor, defer
from twisted.web.client import getPage
from twisted.web.error import Error
def inThread():
  try:
    result = threads.blockingCallFromThread(
      reactor, getPage, &quot;http://twistedmatrix.com/&quot;)
  except Error, exc:
    print exc
  else:
    print result
  reactor.callFromThread(reactor.stop)
reactor.callInThread(inThread)
reactor.run()
&lt;/code&gt;&lt;br /&gt;
blockingCallFromThread将把传递给它的函数所返回的对象返回来、或者把传递给它的函数raise的异常raise出来。如果传给它的函数返回一个Deferred,那么它会返回Deferred的callback收到的数据或者raise Deferred的errback收到的异常（ If the function passed to it returns a Deferred, it will return the value the Deferred is called back with or raise the exception it is errbacked with. ）&lt;br /&gt;
Managing the Thread Pool &lt;br /&gt;
线程池由twisted.python.threadpool.ThreadPool实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可能想修改threadpool的大小，增加或减少使用的线程的数量。我们可以很容易的做到：&lt;/p&gt;

&lt;p&gt;from twisted.internet import reactor&lt;br /&gt;
reactor.suggestThreadPoolSize(30)&lt;br /&gt;
线程池的默认大小取决于所使用的reactor；默认的reactor使用的线程池最小线程数为5最大线程数为10.在修改线程池大小之前一定要小心并且要保证已经理解线程以及线程对资源的使用。&lt;br /&gt;
===================================================================================================================================================================== &lt;br /&gt;
Deferred Reference &lt;br /&gt;
Defrereds &lt;br /&gt;
twisted用Deferred对象管理回调序列。客户程序把一系列的函数附加到deferred上，当异步请求的结果可用时这些函数会被调用,这一系列的函数就是回调(callback)，或者说回调链(callback chain).如果异步请求发生错误也会有一系列的函数被调用，这些函数就是错误回调(errback)或者错误回调链(errback chain)。当结果可用时异步库的代码调用第一个callback，或者当错误发生时调用第一个errback， Deferred对象会把每个callback/errback函数的结果hold住并传入链中的下一个函数 。&lt;/p&gt;

&lt;p&gt;twisted.internet.defer.Deferred对象是函数将会在某个点上产生结果的承诺。我们可以把callback函数附加到给一个Deferred，一旦Deferred得到了结果这些callbacks就会被执行。&lt;/p&gt;

&lt;p&gt;如果不显式的return a twisted.python.failure.Failure或者raise an exception，错误会停止传播 ，正常的callbacks会从这个点上继续执行(详情参见页面上的链路图，一个callback跟一个errback对应，每个callback(errback)的结果传递给下一个callback/errback，同级的errback(callback)没机会执行了)，使用errback返回的结果。如果确实return a twisted.python.failure.Failure或者raise an exception，那么错误会传递给下一个errback.&lt;/p&gt;

&lt;p&gt;如果一个errback不返回任何东西，就等效于返回了一个None对象，那么意味着callbacks会在这errback之后继续执行。callback会用None作为参数，所以要小心！&lt;/p&gt;

&lt;p&gt;twisted.python.failure.Failure实例有一个有用的函数叫trap,可用于作如下等效行为：&lt;/p&gt;

&lt;p&gt;try:&lt;br /&gt;
    # code that may throw an exception&lt;br /&gt;
    cookSpamAndEggs()&lt;br /&gt;
except (SpamException, EggException):&lt;br /&gt;
    # Handle SpamExceptions and EggExceptions&lt;br /&gt;
    …&lt;br /&gt;
等效于&lt;/p&gt;

&lt;p&gt;def errorHandler(failure):&lt;br /&gt;
    failure.trap(SpamException, EggException)&lt;br /&gt;
    # Handle SpamExceptions and EggExceptions&lt;br /&gt;
d.addCallback(cookSpamAndEggs)&lt;br /&gt;
d.addErrback(errorHandler)&lt;br /&gt;
如果传递给trap的参数跟Failure中封装的错误不匹配，trap会re-raise那个错误。&lt;/p&gt;

&lt;p&gt;twisted.internet.defer.Deferred.addCallbacks()&lt;/p&gt;

&lt;h1 id=&quot;case-1&quot;&gt;Case 1&lt;/h1&gt;
&lt;p&gt;d = getDeferredFromSomewhere()&lt;br /&gt;
d.addCallback(callback1)       # A&lt;br /&gt;
d.addErrback(errback1)         # B&lt;br /&gt;
d.addCallback(callback2)       &lt;br /&gt;
d.addErrback(errback2)        &lt;br /&gt;
# Case 2&lt;br /&gt;
d = getDeferredFromSomewhere()&lt;br /&gt;
d.addCallbacks(callback1, errback1)  # C&lt;br /&gt;
d.addCallbacks(callback2, errback2)&lt;br /&gt;
如果callback1中发生错误，Case 1中errback1会被调用来处理Failure；Case 2中errback2会被调用来处理Failure。&lt;/p&gt;

&lt;p&gt;在Case 1中，line A的callback会处理getDeferredFromSomewhere中的成功结果，line B的errback会处理上流代码(the upstream source)中的错误或者A中的错误。&lt;/p&gt;

&lt;p&gt;在Case 2中，line C的errback只处理getDeferredFromSomewhere中抛出的错误，不会处理callback1中抛出的错误。&lt;/p&gt;

&lt;p&gt;对于没有添加errback而发生错误的情况，Deferred被垃圾回收的时候，twisted会把错误的调用栈(traceback)打印到日志文件。所以要小心，如果我们保留了一个对Deferred的引用，从而阻止了它被垃圾回收，那么我们永远都看不到这个错误 （并且会发现我们的callback很神秘的从不被调用）。如果不确定是否有errback忘写，可以显式的在我们callbacks后面追加一个如下所示的errback：&lt;/p&gt;

&lt;p&gt;from twisted.python import log&lt;br /&gt;
d.addErrback(log.err)&lt;br /&gt;
Handling either synchronous or asynchronous results &lt;br /&gt;
有些应用程序中，函数要嘛是异步的(返回一个Deferred,当数据到达时fire这个Deferred)要嘛是同步的(立马返回一个结果)。不过，也有些函数需要同时接受立即结果和Deferreds.&lt;/p&gt;

&lt;p&gt;同步函数：&lt;/p&gt;

&lt;p&gt;def authenticateUser(isValidUser, user):&lt;br /&gt;
    if isValidUser(user):&lt;br /&gt;
        print “User is authenticated”&lt;br /&gt;
    else:&lt;br /&gt;
        print “User is not authenticated”&lt;br /&gt;
异步函数：&lt;br /&gt;
from twisted.internet import reactor, defer&lt;br /&gt;
def asynchronousIsValidUser(user):&lt;br /&gt;
    d = defer.Deferred()&lt;br /&gt;
    reactor.callLater(2, d.callback, user in [“Alice”, “Angus”, “Agnes”])&lt;br /&gt;
    return d&lt;br /&gt;
twisted.internet.defer.maybeDeferred()可以保证函数的返回值是一个Deferred，即使函数是一个同步函数：&lt;br /&gt;
from twisted.internet import defer&lt;br /&gt;
def printResult(result):&lt;br /&gt;
  if result:&lt;br /&gt;
    print “User is authenticated”&lt;br /&gt;
  else:&lt;br /&gt;
    print “User is not authenticated”&lt;br /&gt;
def authenticateUser(isValidUser, user):&lt;br /&gt;
  d = defer.maybeDeferred(isValidUser, user)&lt;br /&gt;
  d.addCallback(printResult)&lt;br /&gt;
isValidUser是synchronousIsValidUser或者asynchronousIsValidUser都行。&lt;/p&gt;

&lt;p&gt;当然，我们也可以修改synchronousIsValidUser使其返回一个Deferred.(https://twistedmatrix.com/documents/current/core/howto/gendefer.html)&lt;/p&gt;

&lt;p&gt;有时候我们需要在几个不同的事件都发生了才被通知，而不是分别等待每个事件。例如，我们可能需要等待一个列表中的连接全部关闭。 twisted.internet.defer.DeferredList就是干这个的。&lt;/p&gt;

&lt;p&gt;根据多个Deferred来创建一个DeferredList，我们只需简单的把一个存储着目标Deferred的list传递进去就行了：&lt;/p&gt;

&lt;p&gt;dl = defer.DeferredList([deferred1,deferred2,deferred3])&lt;br /&gt;
现在我们可以把DeferredList当成一个普通的Deferred对待；我们可以调用addCallbacks等方法。 DeferredList会在所有Deferreds完成的时候调用它的callback. callback会以DeferredList包含的所有Deferred的结果构成的list作为参数进行执行 ，like so:&lt;/p&gt;

&lt;h1 id=&quot;a-callback-that-unpacks-and-prints-the-results-of-a-deferredlist&quot;&gt;A callback that unpacks and prints the results of a DeferredList&lt;/h1&gt;
&lt;p&gt;def printResult(result):&lt;br /&gt;
  for (success, value) in result:&lt;br /&gt;
    if success:&lt;br /&gt;
      print ‘Success:’, value&lt;br /&gt;
    else:&lt;br /&gt;
      print ‘Failure:’, value.getErrorMessage()&lt;/p&gt;

&lt;h1 id=&quot;create-three-deferreds&quot;&gt;Create three deferreds.&lt;/h1&gt;
&lt;p&gt;deferred1 = defer.Deferred()&lt;br /&gt;
deferred2 = defer.Deferred()&lt;br /&gt;
deferred3 = defer.Deferred()&lt;/p&gt;

&lt;h1 id=&quot;pack-them-into-a-deferredlist&quot;&gt;Pack them into a DeferredList&lt;/h1&gt;
&lt;p&gt;dl = defer.DeferredList([deferred1, deferred2, deferred3], consumeErrors=True)&lt;/p&gt;

&lt;h1 id=&quot;add-our-callback&quot;&gt;Add our callback&lt;/h1&gt;
&lt;p&gt;dl.addCallback(printResult)&lt;/p&gt;

&lt;h1 id=&quot;fire-our-three-deferreds-with-various-values&quot;&gt;Fire our three deferreds with various values.&lt;/h1&gt;
&lt;p&gt;deferred1.callback(‘one’)&lt;br /&gt;
deferred2.errback(Exception(‘bang!’))&lt;br /&gt;
deferred3.callback(‘three’)&lt;/p&gt;

&lt;h1 id=&quot;at-this-point-dl-will-fire-its-callback-printing&quot;&gt;At this point, dl will fire its callback, printing:&lt;/h1&gt;
&lt;p&gt;#	Success: one&lt;br /&gt;
#	Failure: bang!&lt;br /&gt;
#	Success: three&lt;br /&gt;
# (note that defer.SUCCESS == True, and defer.FAILURE == False)&lt;br /&gt;
标准的DeferredList不会调用errback,但是传给DeferredList的Deferred发生的failure还是会调用errback除非DeferredList的consumeErrors被设成了True(这句话很绕，我理解的意思是，DeferredList只会等待所有Deferred的异步数据到大后才会执行callback,但是不会执行errback；而构成DeferredList的Deferred发生错误时还是可以调用自己的errback；要想阻止Deferred调用自己的errback,需要在构建DeferredList时设置参数consumeError=True.这个理解需要回头用程序验证一下！！)。&lt;br /&gt;
如果要为构成DeferredList的独立的Deffered提供callback，我们应该对于这些callback添加的时间点很小心。添加一个Deferred到DeferedList的行为实际上内部为Deferred插入了一个callback(当这个callback执行的时候，它检查DeferredList是否已经完成了(我理解的意思是，这个callback检测自己是否是最后一个完成的Deferred，如果是的话就可以调用DefferredList的callback了)).要记住的很重要的事情是，这个内部自动加入的callback它记录的值会是作为result list传入给DefferedList callback函数的东东。&lt;/p&gt;

&lt;p&gt;因此，如果我们在把Deferred加入到DeferredList之后再添加一个callback给Deferred，那么这个callback返回的值将不会传给DeferredList的callback（擦，这么说的话，DeferredList不但要等待它内部所有Deferred的数据到达，而且还要等所有Deferred的callback执行完成，然后把最后的结果合一起作为DeferredList等待的数据）. 为了避免困惑，我们建议不要在Deferred添加到DeferredList之后再为Deferred添加callback.&lt;/p&gt;

&lt;p&gt;def printResult(result):&lt;br /&gt;
  print result&lt;br /&gt;
def addTen(result):&lt;br /&gt;
  return result + “ ten”&lt;/p&gt;

&lt;h1 id=&quot;deferred-gets-callback-before-deferredlist-is-created&quot;&gt;Deferred gets callback before DeferredList is created&lt;/h1&gt;
&lt;p&gt;deferred1 = defer.Deferred()&lt;br /&gt;
deferred2 = defer.Deferred()&lt;br /&gt;
deferred1.addCallback(addTen)&lt;br /&gt;
dl = defer.DeferredList([deferred1, deferred2])&lt;br /&gt;
dl.addCallback(printResult)&lt;br /&gt;
deferred1.callback(“one”) # fires addTen, checks DeferredList, stores “one ten”&lt;br /&gt;
deferred2.callback(“two”)&lt;br /&gt;
# At this point, dl will fire its callback, printing:&lt;br /&gt;
#	 [(1, ‘one ten’), (1, ‘two’)]&lt;/p&gt;

&lt;h1 id=&quot;deferred-gets-callback-after-deferredlist-is-created&quot;&gt;Deferred gets callback after DeferredList is created&lt;/h1&gt;
&lt;p&gt;deferred1 = defer.Deferred()&lt;br /&gt;
deferred2 = defer.Deferred()&lt;br /&gt;
dl = defer.DeferredList([deferred1, deferred2])&lt;br /&gt;
deferred1.addCallback(addTen) # will run &lt;em&gt;after&lt;/em&gt; DeferredList gets its value&lt;br /&gt;
dl.addCallback(printResult)&lt;br /&gt;
deferred1.callback(“one”) # checks DeferredList, stores “one”, fires addTen&lt;br /&gt;
deferred2.callback(“two”)&lt;br /&gt;
# At this point, dl will fire its callback, printing:&lt;br /&gt;
#	 [(1, ‘one), (1, ‘two’)]&lt;br /&gt;
Other behaviours &lt;br /&gt;
fireOnOneCallback DeferredList会在有Deferred调用callback时立马调用自己的callback,然后DeferredList不做任何事儿了，忽略其他还没完成的Deferred&lt;/p&gt;

&lt;p&gt;fireOnOneErrback DeferredList会在有Deferred调用errback时立马调用自己的errback,然后DeferredList不做任何事儿了，忽略其他还没完成的Deferred&lt;/p&gt;

&lt;p&gt;consumeErrors 阻止错误在DeferredList包含的任何Deferred的链路上传播（普通创建的DeferredList不会影响结果在它的Deferred的callbacks和errbacks中传递）。用这个选项在DeferedList中停止错误，将阻止“Unhandled error in Deferred”警告出现在DeferredList包含的没必要添加额外errbacks的Deferred中。设置consumeErrors参数为true不会改变fireOnOneCallback或者fireOnOneErrback.&lt;/p&gt;

&lt;p&gt;DeferredList的一个常见应用是join若干平行的异步操作，如果所有操作都成功就成功完成，如果任何一个操作失败就失败。这种情况下，twisted.internet.defer.gatherResults是一个有用的捷径：&lt;/p&gt;

&lt;p&gt;from twisted.internet import defer&lt;br /&gt;
d1 = defer.Deferred()&lt;br /&gt;
d2 = defer.Deferred()&lt;br /&gt;
d = defer.gatherResults([d1, d2], consumeErrors=True)&lt;br /&gt;
def printResult(result):&lt;br /&gt;
  print result&lt;br /&gt;
d.addCallback(printResult)&lt;br /&gt;
d1.callback(“one”)&lt;br /&gt;
# nothing is printed yet; d is still awaiting completion of d2&lt;br /&gt;
d2.callback(“two”)&lt;br /&gt;
# printResult prints [“one”, “two”]&lt;br /&gt;
consumeErrors参数跟DeferredList有一样的意义：如果为true,gatherResults会消耗掉传进来的Deferred的所有错误。这个参数都设为true吧，除非我们要为传进来的Deferred添加callbacks或者errbacks,或者除非我们知道他们不会失败。如果不设为true,失败会导致twisted记录一个unhandled error到日志里。这个参数从twisted 11.1.0之后有效。&lt;/p&gt;
</description>
        <pubDate>Thu, 15 Jan 2015 21:02:00 +0800</pubDate>
        <link>/2015/01/15/adbapi/</link>
        <guid isPermaLink="true">/2015/01/15/adbapi/</guid>
        
        
        <category>server</category>
        
      </item>
    
      <item>
        <title>bsd socket api</title>
        <description>
&lt;ul&gt;
  &lt;li&gt;###int socket ( int family, int type, int protocol)
    &lt;ul&gt;
      &lt;li&gt;创建一个socket，返回一个socket描述符&lt;code&gt;sockFD&lt;/code&gt;，可以理解为一个句柄,是一个small无符号整数,这个句柄可以使用所有其他的socket操作，返回-1时表示跪了   &lt;/li&gt;
      &lt;li&gt;family: 当前协议族只能是&lt;code&gt;AF_INET&lt;/code&gt;,因为没有支持IPv6，所以没有AF_INET6&lt;/li&gt;
      &lt;li&gt;type: &lt;code&gt;SOCK_STREAM&lt;/code&gt;是tcp流式，&lt;code&gt;SOCK_DGRAM&lt;/code&gt;是udp数据包式&lt;/li&gt;
      &lt;li&gt;protocol: &lt;code&gt;PF_INET&lt;/code&gt;或者是&lt;code&gt;PF_UNSPEC&lt;/code&gt;,两者都可以，前者只能接受v4的协议，后者通吃。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;###int socket_bind ( int sockFD, const struct sockaddr *myAddr, int addrLength)
    &lt;ul&gt;
      &lt;li&gt;绑定一个socket到本地的端口&lt;em&gt;and/or&lt;/em&gt;ip地址，不管是ip还是port都可以在库自动选择的情况下得到通配，通配port的话，把address中&lt;code&gt;sin_port&lt;/code&gt;域设置0，通配ip的话，把address中的&lt;code&gt;sin_addr.s_addr&lt;/code&gt;设置0，和socket()一样，返回-1表示跪了，返回0表示ok&lt;/li&gt;
      &lt;li&gt;tcp有一个端口重用时限机制，如果一个应用试图连续在短时间内第二次绑定同一个本地端口，会出现一个EADDRINUSE错误，等等就好了(这也行。。。)&lt;/li&gt;
      &lt;li&gt;注意第二个参数，本质上是一个&lt;code&gt;struct sockaddr_in*&lt;/code&gt;，被转换成了一个更加通用的&lt;code&gt;struct sockaddr*&lt;/code&gt;，因为网络地址是被Socket Library所使用（这儿不太懂）&lt;/li&gt;
      &lt;li&gt;不是必须在connect之前使用bind，如果一个socket没有绑定的话，库会选择本地的port和ip&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;###int socket_connect(int sockFD, struct sockaddr *servAddr, int addrLength)
    &lt;ul&gt;
      &lt;li&gt;通过一个给定的port连接远程主机，如果这是一个流式(tcp)socket,会执行一个tcp协商(negotation)来打开一个连接，如果是数据报式(udp)socket，会把地址存储起来，之后会和某些socket操作一起作用，这里比较重要的一点就是，使用udp的情况下，不需要握手，只有根据通信时有没有数据包来判断是否连接成功，所以在通过这个socket进行读写的情况下才会报错。返回-1给跪，0ok&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;###int socket_select(int maxFDsExamined, fd_set *readFDs, fd_set *writeFDs, fd_set *exceptFDs, struct timeval *timeOut)
    &lt;ul&gt;
      &lt;li&gt;可以轮询一个或多个socket，常用于实现非阻塞socket编程,同样error返回-1（这个函数篇幅有限，详情百度）&lt;/li&gt;
      &lt;li&gt;maxFDsExamined: 描述轮询的句柄范围，要比最大的socket句柄都要大,起兼容作用，windows上无所谓，可以忽略&lt;/li&gt;
      &lt;li&gt;readfds：（可选）指针，指向一组等待可读性检查的套接口。&lt;/li&gt;
      &lt;li&gt;writefds：（可选）指针，指向一组等待可写性检查的套接口。&lt;/li&gt;
      &lt;li&gt;exceptfds：（可选）指针，指向一组等待错误检查的套接口。&lt;/li&gt;
      &lt;li&gt;timeout：select()最多等待时间，对阻塞操作则为NULL，{0,0}表示立即返回，非阻塞。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;###socket_fcntl(int sockFD, int command, int flags)
    &lt;ul&gt;
      &lt;li&gt;可以改变一个已经打开的socketFD句柄属性，目前唯一支持的flag是&lt;code&gt;O_NONBLOCK&lt;/code&gt;，可以把socket变为非阻塞模式&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;command: 等于&lt;code&gt;F_GETFL&lt;/code&gt;的时候，返回这个sockFD当前的flag，等于&lt;code&gt;F_SETFL&lt;/code&gt;的时候，将后面传入的flags参数设置为sockFD的flag，error时返回-1比较正统的方法如下&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  lags = socket_fcntl(sockfd, F_GETFL,0）;
  flags |= O_NONBLOCK;
  err = socket_fcntl(sockefd, F_SETFL, flags);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;###int socket_getpeername(int sockFD, struct sockaddr *peerAddr, int *addrLength)
    &lt;ul&gt;
      &lt;li&gt;获取远程主机的地址，成功返回0，如果没有之前没有连接成功，GetMITLibError()会返回ENOTCONN错误，且返回-1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;###int socket_getsockname(int sockFD, struct sockaddr *localAddr, int *addrLength)
    &lt;ul&gt;
      &lt;li&gt;获取该socket的本地port和address，0成功，-1失败&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;###int socket_read(int sockFD, void *buffer, UInt32 numBytes)
    &lt;ul&gt;
      &lt;li&gt;从socket中将数据读取到buffer中，numBytes应该是buffer的大小，read函数可能不会装满这个buffer，返回值是所读取数据的大小，失败返回-1，如果返回0，说明socket收到了一个EOF（比如远程主机关闭了）&lt;/li&gt;
      &lt;li&gt;如果在socket上想要完整的执行读取，在读满自己希望的大小之前继续调用read，值得注意的是，如果没有数据可读的时候，read函数会阻塞，这个状态可以通过select查看到。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;###int socket_write(int sockFD, void *buffer, UInt32 numBytes)
    &lt;ul&gt;
      &lt;li&gt;把numBytes大小的数据从buffer中写入到socket里，同样，write可能也不会把buffer全部写入，返回值是实际写入的大小，失败返回-1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;###int socket_readv(int sockFD, struct iovec *iov, UInt32 iovCount)
    &lt;ul&gt;
      &lt;li&gt;等价于read，但是会把数据存放在iov数组的成员里：iov[0],iov[1]…iov[iovCount-1],iovCount的取值范围是(0,IOV_MAX]，把数据分散存放&lt;/li&gt;
      &lt;li&gt;struct iovec的两个成员：&lt;code&gt;caddr_t iov_base&lt;/code&gt;和&lt;code&gt;int iov_len&lt;/code&gt;，前者是数据存放的首地址，后者是该数据片的长度，readv函数会按顺序填充这些数据片&lt;/li&gt;
      &lt;li&gt;返回值是读取数据的总大小，失败时返回-1,0是EOF&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;###int socket_recv(int sockFD, void *buffer, UInt32 numBytes, int flags)
    &lt;ul&gt;
      &lt;li&gt;这个函数和read很像，除了最后一个参数，如果flags被设置为&lt;code&gt;MSG_DONTWAIT&lt;/code&gt;，那么当数据不可用的时候这个函数会变成非阻塞。&lt;/li&gt;
      &lt;li&gt;返回值是读取的数据的总数，返回-1时error&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;###int socket_send(int sockFD, void *buffer, UInt32 numBytes, int flags)
    &lt;ul&gt;
      &lt;li&gt;和write相似，同样如果flags被设置为&lt;code&gt;MSG_DONTWAIT&lt;/code&gt;时，此函数会变为非阻塞。&lt;/li&gt;
      &lt;li&gt;返回值是写入的数据的总数，返回-1时error&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;###int socket_recvfrom(int sockFD, void *buffer, UInt32 numBytes, int flags, struct sockaddr *fromAddr, socklen_t *addrLength)
    &lt;ul&gt;
      &lt;li&gt;从fromAddr指定的远程主机读取信息，要求socket必须为数据报式(udp)，numBytes是buffer的大小，不保证填满buffer，返回值是读取数据的总大小，失败时返回-1&lt;/li&gt;
      &lt;li&gt;如果flags被设置为&lt;code&gt;MSG_DONTWAIT&lt;/code&gt;时，此函数会变为非阻塞&lt;/li&gt;
      &lt;li&gt;fromAddr本质上是一个struct sockaddr_in*类型&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;###int socket_sendto(int sockFD, void *buffer, UInt32 numBytes, int flags, struct sockaddr *toAddr, socklen_t addrLength)
    &lt;ul&gt;
      &lt;li&gt;向toAddr指定的远程主机发送信息，要求socket必须为数据报式(udp)，numBytes是要发送数据的大小，不保证全部输出buffer，返回值是读取数据的总大小，失败时返回-1&lt;/li&gt;
      &lt;li&gt;如果flags被设置为&lt;code&gt;MSG_DONTWAIT&lt;/code&gt;时，此函数会变为非阻塞&lt;/li&gt;
      &lt;li&gt;fromAddr本质上是一个struct sockaddr_in*类型&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;###int socket_shutdown(int sockFD, int howTo)
    &lt;ul&gt;
      &lt;li&gt;单向或者双向的关闭一个连接着的socket，返回0是ok，-1是error&lt;/li&gt;
      &lt;li&gt;howTo：
        &lt;ul&gt;
          &lt;li&gt;&lt;code&gt;SHUT_RD&lt;/code&gt;关闭正在read的端，这时socket便不再可读&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;SHUT_WR&lt;/code&gt;关闭正在write的端，这时socket会向远程主机发送一个断开的指令，告诉对方这里已经不会再write任何东西，不再可写&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;SHUT_RDWR&lt;/code&gt;关闭连接的两端，之后依旧需要使用close来释放掉socket&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;###int socket_close(int sockFD)
    &lt;ul&gt;
      &lt;li&gt;释放掉一个socket的资源，与远程主机断开连接，这是必须要有的，不管tcp还是udp都需要执行这一步，返回0是ok，-1是error&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;转载请注明出处&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Jan 2015 19:44:00 +0800</pubDate>
        <link>/2015/01/07/bsd-socket-api/</link>
        <guid isPermaLink="true">/2015/01/07/bsd-socket-api/</guid>
        
        
        <category>network</category>
        
      </item>
    
  </channel>
</rss>
