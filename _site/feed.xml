<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zebulon</title>
    <description>Stories About the Indie Game Developer</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 22 Aug 2015 20:49:56 +0800</pubDate>
    <lastBuildDate>Sat, 22 Aug 2015 20:49:56 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>1</title>
        <description>&lt;p&gt;项目需要发行台湾版本，也就是繁体版，需要把所有策划案，数值表和代码文件提供给台湾运营商然后人肉翻译，这个脚本就是为了解救生活于水深火热的台湾同胞而产生的。
这个脚本的思路是读取文件-&amp;gt;decode原始字符-&amp;gt;简体转繁体-&amp;gt;encode-&amp;gt;输出文件。
实际生产环境中，decode和简转繁过程有几个问题：
* 各个需要转换的文件于不同时期，用不同的工具，由不同的人制作，所以文件之间有相当大的可能性存在字符集不同一的问题，甚至同一个文件中不同行的字符集都不同。另外，文件中全角半角符号不统一也很常见，导致python中decode这些字符的时候会乱码或者error。
* 简体转繁体不是简单的将简体字转换为繁体字，双方的语言习惯上也有很大不同，举个例子，大陆的”服务器“在台湾叫做”伺服器“，类似的还有很多，甚至句子的词序也会不同&lt;/p&gt;

&lt;p&gt;解决方法：
* 按行读取文件，然后分析该行的字符集，然后针对该字符集进行decode，最后全角转半角。
* 简转繁有现成的py开源库，用到两个文件，&lt;a href=&quot;https://github.com/skydark/nstools/blob/master/zhtools/zh_wiki.py&quot;&gt;zh_wiki.py&lt;/a&gt;和&lt;a href=&quot;https://github.com/skydark/nstools/blob/master/zhtools/langconv.py&quot;&gt;langconv.py&lt;/a&gt;,例如使用Converter(“zh-hant”).convert(line)就可以将一行简体半角unicode转为繁体,第一个文件是从wiki上扒下来的简体繁体对应字典，包含了字词的转换，无法完成对句子的处理，但是根据台湾方面的反应，这样的转换效果已经大大超出了他们的预期，同样超过了boss对我的预期。。。
* 全角符号的范围在[65281,65374]之间，且除了空格之外，都比对应的半角字符大了65245，全角空格是12288，半角是32，所以根据ord（uchar）判断字符全角还是半角然后进行处理即可。&lt;/p&gt;

&lt;p&gt;```python
# coding = utf-8
import os, re, platform, chardet, linecache, sys, codecs
from langconv import *&lt;/p&gt;

&lt;p&gt;def getSuffixConfig():
	‘’’
	获取后缀配置列表
	‘’’
	suffixList = []
	re_fix = re.compile(“^.\w*”)
	config = open(“getSuffixConfig.txt”, “r”)
	for line in config.readlines():
		if re_fix.findall(line):
			suffixList.append(line)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.close()
return suffixList
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;def getCharDet(filename):
	‘’’
	获取字符集
	‘’’
	detFile = open(filename, “r”)
	encoding = {}
	fileData = detFile.read()
	if len(fileData) &amp;gt; 0:
		encoding = chardet.detect(fileData)
	detFile.close()
	if encoding:
		return encoding[“encoding”]
	else:
		return “”&lt;/p&gt;

&lt;p&gt;def strQ2B(ustring):
	‘’’
	全角转半角
	‘’’
	rstring = “”
	for uchar in ustring:
		inside_code = ord(uchar)
		if inside_code == 12288:	#空格
			inside_code = 32
		elif: (inside_code &amp;gt;= 65281 and inside_code &amp;lt;= 65374):
			inside_code -= 65245
		rstring += unichr(inside_code)
	return rstring&lt;/p&gt;

&lt;p&gt;def walkCallback(args, dire, fis):
	‘’’
	walk遍历的每步回调
	‘’’
	fix_list = getSuffixConfig()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for f in fis:
	print args[1] + dire[line(args[2]):]
	Ext = os.path.splitext(f)
	for suffix in fix_list:
		if Ext[1] == suffix:
			convFile = open(dire + os.sep + f, &quot;r&quot;)
			if not os.path.exists(args[1] + dire[len(args[2]):]):
				os.makedirs(args[1] + dire[len(args[2]):])
			outFile = open(args[1] + dire[len(args[2]):] + os.sep + f, &quot;w&quot;)

			print f + &quot; -&amp;gt; started&quot;
			tempCharSet = getCharDet(dire + os.sep + f)
			if not tempCharSet:
				print &quot;tempCharSet is null&quot;
				continue	#空文件
			if args[0] == &quot;1&quot; :
				index = 1
				charSet = &quot;&quot;
				for line in convFile.readlines():
					charSet = chardet.detect(line)[&quot;encoding&quot;]
					if not charSet:
						charSet = tempCharSet
					if not isinstance(line, unicode):
						res_test = &quot;&quot;
						try:
							try:
								res_test = line.decode(&quot;utf-8&quot;)
							except:
								res_test = line.decode(&quot;GB18030&quot;)
						except:
							res_test = line.decode(charSet)
							raw_input(&quot;error&quot;)	#提示错误
							line = res_test
					line = strQ2B(line)
					line = Converter(&quot;zh-hant&quot;).convert(line)
					line = line.encode(&quot;utf-8&quot;)
					outFile.write(line)
					index += 1
				convFile.close()
				outFile.close()
				print f + &#39; -&amp;gt; Done!\n&#39;
				break
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;main&quot;&gt;main&lt;/h1&gt;
&lt;p&gt;if platform.system() != “Windows”:
	print “Please run this script based on windows system”
else :
	reload(sys)
	sys.setdefaultencoding(‘GB18030’)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root_str = &quot;需要转换的目录（当前系统目录分隔符\&#39;&quot; + os.sep + &quot;\&#39;）：&quot;
root = raw_input(root_str.decode(&quot;utf-8&quot;).encode(&quot;gbk&quot;))

out_str = &quot;输出目录（当前系统目录分隔符\&#39;&quot; + os.sep + &quot;\&#39;）：&quot;
out = raw_input(out_str.decode(&quot;utf-8&quot;).encode(&quot;gbk&quot;))

switch_str = &quot;转换方向 1-&amp;gt;简转繁  2-&amp;gt;繁转简:&quot;
t_s_switch =  raw_input(switch_str.decode(&quot;utf-8&quot;).encode(&quot;gbk&quot;))

print &quot;\nStart&quot;
os.path.walk(root, walkCallback, (t_s_switch, out, root))
print &quot;\nAll Finished&quot; ```
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;代码中的后缀配置文件getSuffixConfig.txt的格式像下面这样就行
&lt;code&gt;
.cpp
.h
.lua
...
&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;对于解析字符集使用的&lt;a href=&quot;https://pypi.python.org/pypi/chardet&quot;&gt;chardet&lt;/a&gt;，这是一个python插件包，我用的是2.3版本，适配2.6以上的python，下的时候注意一下版本要求，安装过程和使用方法很简单，这里不再赘述。&lt;/li&gt;
  &lt;li&gt;最终效果就是一次性完成了所有转换工作，实际运行0bug，为台湾运营商争取了两周多的时间，让人们可以免于加班，早点回家和家人吃饭或者和恋人Facetime，想到这，我心安理得的给自己的面条加了个蛋。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 15 Jun 2015 16:51:00 +0800</pubDate>
        <link>/2015/06/15/1/</link>
        <guid isPermaLink="true">/2015/06/15/1/</guid>
        
        <category>Python</category>
        
        
      </item>
    
      <item>
        <title>3.x的sqlite在Android读写失败</title>
        <description>&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;问题描述如题，解决方法：直接在软件内读取会失败，需要复制到可写路径内&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  sqlite3* dbFile = NULL;

  std::string path;

  path = FileUtils::getInstance()-&amp;gt;fullPathForFilename(&quot;db1.db&quot;);
    
  //安卓平台
  #if CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID
      path  = FileUtils::getInstance()-&amp;gt;getWritablePath();
      path  += &quot;/db1.db&quot;;

      FILE* file = fopen(path.c_str(), &quot;r&quot;);
      if (file == nullptr)
      {
          ssize_t size;
          const char* data = (char*) FileUtils::getInstance()-&amp;gt;getFileData(&quot;db1.db&quot;, &quot;rb&quot;, &amp;amp;size);
          file = fopen(path.c_str(), &quot;wb&quot;);
          fwrite(data, size, 1, file);
          CC_SAFE_DELETE_ARRAY(data);
      }
      fclose(file);

  #endif

  CCLOG(&quot;数据库路径：%s&quot;, path.c_str());
  int resultOK = sqlite3_open(path.c_str(), &amp;amp;dbFile);

  if (resultOK != SQLITE_OK) {
      sqlite3_close(dbFile);
      CCLOG(&quot;数据库打开失败: %d&quot;, resultOK);
      return;
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 05 Apr 2015 20:35:00 +0800</pubDate>
        <link>/2015/04/05/3.x%E7%9A%84sqlite%E5%9C%A8Android%E8%AF%BB%E5%86%99%E5%A4%B1%E8%B4%A5/</link>
        <guid isPermaLink="true">/2015/04/05/3.x%E7%9A%84sqlite%E5%9C%A8Android%E8%AF%BB%E5%86%99%E5%A4%B1%E8%B4%A5/</guid>
        
        
        <category>cocos</category>
        
      </item>
    
      <item>
        <title>妹子面试备忘</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;一、测试工具&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#androidmonkey&quot;&gt;1. AndroidMonkey压力测试工具&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;特征&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;基本语法如下&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#monkey-test&quot;&gt;Monkey Test执行过程中在下列三种情况下会自动停止：&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;使用流程&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#spoon&quot;&gt;2．Spoon自动化兼容性测试工具&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;截图&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;执行&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#selectorchapek-for-android&quot;&gt;3．SelectorChapek for Android插件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#jdgui-&quot;&gt;4．Jdgui 反编译工具&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-6&quot;&gt;反编译步骤&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#androidfby-&quot;&gt;5．Androidfby 反编译工具&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#git-&quot;&gt;6．GIT 版本控制&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-7&quot;&gt;部分常用命令&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#section-8&quot;&gt;查看、添加、提交、删除、找回，重置修改文件&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#diff&quot;&gt;查看文件diff&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-9&quot;&gt;查看提交记录&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-10&quot;&gt;远程分支管理&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-11&quot;&gt;优点&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#svn-&quot;&gt;7．SVN 版本控制&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-12&quot;&gt;优点&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-13&quot;&gt;缺点&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-14&quot;&gt;二、游戏测评&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-15&quot;&gt;《部落冲突》&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#q&quot;&gt;富有传奇色彩的人物设计：Q版却不失大气！&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-16&quot;&gt;丰富的策略性：每个人都是军事家&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-17&quot;&gt;游戏画面和战斗特效：赞！&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-18&quot;&gt;因为是第一个 所以经典&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-19&quot;&gt;玩家人格魅力的体现&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#mt&quot;&gt;《我叫mt》&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-20&quot;&gt;画面&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-21&quot;&gt;核心玩法&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-22&quot;&gt;游戏追求&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-23&quot;&gt;游戏节奏&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-24&quot;&gt;《刀塔传奇》&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-25&quot;&gt;玩法&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-26&quot;&gt;画面&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-27&quot;&gt;音效&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-28&quot;&gt;操作&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-29&quot;&gt;收费&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#deemo&quot;&gt;《Deemo》（《古树旋律》）&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-30&quot;&gt;概述我见：朴实包装下浓浓的音乐呈现&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-31&quot;&gt;外在表现：简约勾勒间满满的氛围表现&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#section-32&quot;&gt;最刺骨的孤独&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-33&quot;&gt;最揪心的归宿&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-34&quot;&gt;最伤感的领悟&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-35&quot;&gt;最华丽的礼物&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-36&quot;&gt;内涵理念：童话故事后深刻的亲情体现&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-37&quot;&gt;特色提炼：黑白键盘上盛放的心灵盛宴&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-38&quot;&gt;一些不足&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;一、测试工具&lt;/h1&gt;

&lt;h2 id=&quot;androidmonkey&quot;&gt;1. AndroidMonkey压力测试工具&lt;/h2&gt;
&lt;p&gt;Monkey是Android中的一个命令行工具，可以运行在模拟器里或实际设备中。它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试。Monkey测试是一种为了测试软件的稳定性、健壮性的快速有效的方法。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;特征&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;测试的对象仅为应用程序包，有一定的局限性。&lt;/li&gt;
  &lt;li&gt;Monky测试使用的事件流数据流是随机的，不能进行自定义。&lt;/li&gt;
  &lt;li&gt;可对MonkeyTest的对象，事件数量，类型，频率等进行设置。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;基本语法如下&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
$ adb shell monkey [options]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;options分为四大类:&lt;code&gt;基本配置&lt;/code&gt;（例如测试事件数量），&lt;code&gt;约束项设置&lt;/code&gt;（例如单独对某个包或多个包），&lt;code&gt;事件类型和频率&lt;/code&gt;，&lt;code&gt;异常忽略选项&lt;/code&gt;等。如果不指定options，Monkey将以无反馈模式启动，并把事件任意发送到安装在目标环境中的全部包。
下面是一个更为典型的命令行示例，它启动指定的应用程序，并向其发送500个伪随机事件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ adb shell monkey -p your.package.name -v 500
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;monkey-test&quot;&gt;Monkey Test执行过程中在下列三种情况下会自动停止：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;如果限定了Monkey运行在一个或几个特定的包上，那么它会监测试图转到其它包的操作，并对其进行阻止。&lt;/li&gt;
  &lt;li&gt;如果应用程序崩溃或接收到任何失控异常，Monkey将停止并报错。&lt;/li&gt;
  &lt;li&gt;如果应用程序产生了应用程序不响应(application not responding)的错误，Monkey将会停止并报错。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;使用流程&lt;/h3&gt;

&lt;p&gt;总的来说使用monkey进行测试是比较简单的，只是需要做一些比较复杂的准备工作，比如配置ADB环境。
* ADB连接Android测试设备
* 确定你要测试的应用的PackageName
* 使用Monkey发一条测试命令&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;spoon&quot;&gt;2．Spoon自动化兼容性测试工具&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    android众多的版本和机型给android app测试工作带来不小的挑战。Spoon通过将case分布式地执行、将执行结果更友好地展示出来，从而简化android app的测试工作。
    Spoon没有开发新的测试框架，而是让已经存在的测试框架更有效。现在的测试框架，一般都是通过测试apk来驱动被测apk，Spoon可以让这些case在多台设备上同时运行。一旦测试结束，Spoon就是生成一份html报表，来展示每台设备上的执行结果。
    Spoon会检测到adb devices命令中显示的全部设备，并在这些设备上执行case。所以我们在使用spoon时，可以插入不同的手机、平板、或者不同配置的模拟器。
    插入的设备越多、越杂，那么最终的测试结果展示的信息就越多。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;截图&lt;/h3&gt;

&lt;p&gt;除了单纯地跑case，Spoon还可以在case执行中，进行截图，并在结果中进行展示。在最后的结果中，我们可以看到不同设备跑一个case时的截图，来测试app的兼容性。
使用Spoon的截图功能，必须在被测app中引入spoon-clientjar包，在我们的测试代码中调用screenshot方法进行截图，这些截图会被打上标签。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
    Spoon.screenshot(activity, &quot;initial_state&quot;);    //这里编写登陆代码    
    Spoon.screenshot(activity, &quot;after_login&quot;);
&lt;/code&gt;
代码里指定的tag用来命名截图，以便在测试兼容性的时候进行不同设备间的横向比较。
我们也可以连贯地浏览每台设备上的截图，来查看运行过程。
###下载
下载最新的runner jar包或者最新的client jar包，或者通过maven来获取：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
    &amp;lt;dependency&amp;gt;   
    &amp;lt;groupId&amp;gt;com.squareup.spoon&amp;lt;/groupId&amp;gt;    
    &amp;lt;artifactId&amp;gt;spoon-client&amp;lt;/artifactId&amp;gt;    
    &amp;lt;version&amp;gt;(insert latest version)&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;执行&lt;/h3&gt;

&lt;p&gt;Spoon既可以单独运行，又可以集成到maven里，作为maven命令的一部分来执行。
    单独运行，需要被测apk包和测试apk包，执行下面的命令即可：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
java -jar spoon-runner-1.0.0-jar-with-dependencies.jar  --apk example-app.apk  --test-apk example-tests.apk
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;执行结果，默认会放在当前目录的spoon-output文件夹下。当然还有一些其他的参数，具体如下：
Options:       &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;–apk               被测apk       &lt;/li&gt;
  &lt;li&gt;–fail-on-failure   Non-zero exit code on failure        &lt;/li&gt;
  &lt;li&gt;–output            结果路径       &lt;/li&gt;
  &lt;li&gt;–sdk               android sdk路径       &lt;/li&gt;
  &lt;li&gt;–test-apk          测试apk       &lt;/li&gt;
  &lt;li&gt;–title             Execution title       &lt;/li&gt;
  &lt;li&gt;–class-name        Test class name to run (fully-qualified)        &lt;/li&gt;
  &lt;li&gt;–method-name       Test method name to run (must also use –class-name)        &lt;/li&gt;
  &lt;li&gt;–no-animations     Disable animated gif generation       &lt;/li&gt;
  &lt;li&gt;–size              Only run test methods annotated by testSize (small, medium, large)       &lt;/li&gt;
  &lt;li&gt;–adb-timeout       Set maximum execution time per test in seconds (10min default)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;selectorchapek-for-android&quot;&gt;3．SelectorChapek for Android插件&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;jdgui-&quot;&gt;4．Jdgui 反编译工具&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    Jdgui是一个图形化工具，用于查看Jar包的源代码，可以和dex2jar在命令行配合使用
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;反编译步骤&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;首先将apk文件，将后缀改为zip，解压，得到其中的classes.dex，它就是java文件编译再通过dx工具打包而成的&lt;/li&gt;
  &lt;li&gt;解压下载的dex2jar，将classes.dex复制到dex2jar.bat所在目录。在命令行下定位到dex2jar.bat所在目录，然后运行&lt;code&gt;dex2jar.bat classes.dex&lt;/code&gt;生成classes.dex.dex2jar.jar&lt;/li&gt;
  &lt;li&gt;在JdGui中打开生成的jar包就可以看到源码了&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;androidfby-&quot;&gt;5．Androidfby 反编译工具&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    相对于上条提到的dex2jar，这是一个图形化的反编译工具，由apk直接生成带有jar的同名目录，然后使用Jdgui查看其源码，如果apk采用了某些加密机制的话，jar中视看不到源码的，这时可以使用命令行的方式（dex2jar)进行尝试。 
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;git-&quot;&gt;6．GIT 版本控制&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    Git是一款免费、开源的`分布式`版本控制系统，用于敏捷高效地处理任何或小或大的项目。分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者机器上都是一个完整的数据库。即使离线，也能继续进行工作。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-7&quot;&gt;部分常用命令&lt;/h3&gt;

&lt;h4 id=&quot;section-8&quot;&gt;查看、添加、提交、删除、找回，重置修改文件&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;git help “command”  # 显示command的help&lt;/li&gt;
  &lt;li&gt;git show            # 显示某次提交的内容 &lt;/li&gt;
  &lt;li&gt;git co  – “file”   # 抛弃工作区修改&lt;/li&gt;
  &lt;li&gt;git co  .           # 抛弃工作区修改&lt;/li&gt;
  &lt;li&gt;git add “file”      # 将工作文件修改提交到本地暂存区&lt;/li&gt;
  &lt;li&gt;git add .           # 将所有修改过的工作文件提交暂存区&lt;/li&gt;
  &lt;li&gt;git rm “file”       # 从版本库中删除文件&lt;/li&gt;
  &lt;li&gt;git rm “file” –cached  # 从版本库中删除文件，但不删除文件&lt;/li&gt;
  &lt;li&gt;git reset “file”    # 从暂存区恢复到工作文件&lt;/li&gt;
  &lt;li&gt;git reset – .      # 从暂存区恢复到工作文件&lt;/li&gt;
  &lt;li&gt;git reset –hard    # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改&lt;/li&gt;
  &lt;li&gt;git revert “$id”    # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象&lt;/li&gt;
  &lt;li&gt;git revert HEAD     # 恢复最后一次提交的状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;diff&quot;&gt;查看文件diff&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;git diff “file”    # 比较当前文件和暂存区文件差异&lt;/li&gt;
  &lt;li&gt;git diff&lt;/li&gt;
  &lt;li&gt;git diff “id1” “id2”   # 比较两次提交之间的差异&lt;/li&gt;
  &lt;li&gt;git diff “branch1”..”branch2” # 在两个分支之间比较 &lt;/li&gt;
  &lt;li&gt;git diff –staged   # 比较暂存区和版本库差异&lt;/li&gt;
  &lt;li&gt;git diff –cached   # 比较暂存区和版本库差异&lt;/li&gt;
  &lt;li&gt;git diff –stat     # 仅仅比较统计信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-9&quot;&gt;查看提交记录&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;git log&lt;/li&gt;
  &lt;li&gt;git log “file”      # 查看该文件每次提交记录&lt;/li&gt;
  &lt;li&gt;git log -p “file”   # 查看每次详细修改内容的diff&lt;/li&gt;
  &lt;li&gt;git log -p -2       # 查看最近两次详细修改内容的diff&lt;/li&gt;
  &lt;li&gt;git log –stat      #查看提交统计信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-10&quot;&gt;远程分支管理&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;git pull                         # 抓取远程仓库所有分支更新并合并到本地&lt;/li&gt;
  &lt;li&gt;git pull –no-ff                 # 抓取远程仓库所有分支更新并合并到本地，不要快进合并&lt;/li&gt;
  &lt;li&gt;git fetch origin                 # 抓取远程仓库更新&lt;/li&gt;
  &lt;li&gt;git merge origin/master          # 将远程主分支合并到本地当前分支&lt;/li&gt;
  &lt;li&gt;git co –track origin/branch     # 跟踪某个远程分支创建相应的本地分支&lt;/li&gt;
  &lt;li&gt;git co -b “local_branch” origin/”remote_branch”  # 基于远程分支创建本地分支，功能同上&lt;/li&gt;
  &lt;li&gt;git push                         # push所有分支&lt;/li&gt;
  &lt;li&gt;git push origin master           # 将本地主分支推到远程主分支&lt;/li&gt;
  &lt;li&gt;git push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)&lt;/li&gt;
  &lt;li&gt;git push origin “local_branch”   # 创建远程分支， origin是远程仓库名&lt;/li&gt;
  &lt;li&gt;git push origin “local_branch”:”remote_branch”  # 创建远程分支&lt;/li&gt;
  &lt;li&gt;git push origin :”remote_branch”  #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支&lt;/branch&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-11&quot;&gt;优点&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;     适合分布式开发，强调个体。公共服务器压力和数据量都不会太大。速度快、灵活。任意两个开发者之间可以很容易的解决冲突。离线工作。 ###缺点

    资料少（起码中文资料很少）。学习周期相对而言比较长。不符合常规思维。代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;svn-&quot;&gt;7．SVN 版本控制&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;SVN是Subversion的简称，是一个开放源代码的`集中式`版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion。
集中式代码管理的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上可以说是无法工作的。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-12&quot;&gt;优点&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;管理方便，逻辑明确，符合一般人思维习惯。易于管理，集中式服务器更能保证安全性。代码一致性非常高。适合开发人数不多的项目开发。大部分软件配置管理的大学教材都是使用svn和vss。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-13&quot;&gt;缺点&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;服务器压力太大，数据库容量暴增。如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-14&quot;&gt;二、游戏测评&lt;/h1&gt;

&lt;h2 id=&quot;section-15&quot;&gt;《部落冲突》&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;《部落冲突》（部落战争）是为芬兰游戏公司Supercell所推出的策略类手机游戏，于2012年8月2日在苹果应用商店发布。该游戏以策略战争为主题，通过经营自己的村庄，玩家可逐渐强大兵力，进而成千上万的玩家进行战斗。村庄到达一定等级后，还可与其他村庄结成部落，进行部落间的战斗。其内容兼具攻、守城及养成元素，玩家于一开始时只有“建筑工人小屋”及各一座等级1的“大本营”、“金矿”、“兵营”以及各750点的“圣水”和“黄金”，第一次进入游戏会进入引导模式让玩家了解此游戏的建造、升级、提速及解锁的方式。随着游戏的进行，到了后期重心将会由单人模式移至多人模式。 2013年9月30日该游戏的安卓版在芬兰和加拿大率先推出，2013年10月7日Supercell在世界其他国家的 Google Play市场推出了该游戏。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;q&quot;&gt;富有传奇色彩的人物设计：Q版却不失大气！&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;COC第一个出场的典型角色屌丝兵野蛮人是很多人一开始喜欢用的士兵，也是小编最喜爱的一个角色，他们淌着口水，挥舞着发光的剑刃，不畏惧战火，在部落里奔跑抢夺着，那画面实在是太萌，太讨人喜欢；哥布林身手最快，抢钱最拿手，但也死得也快，一开始我还没有学会活用这个类型的士兵，直到后面有一次认真一用，才发现，升本的资源全靠他啊！巨人是最耐用的炮灰，虽然觉得让自己的士兵去挡枪口这种事太残忍，可每一次攻击都少不了他，没有他，战斗的胜算率基本等于零啊；还有天使胖子和杀伤力极强的龙，这两个飞在天上的，带出去打战就拉风得不得了有木有，以及会使用魔法攻击的法师，简直是守城的心头好！
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-16&quot;&gt;丰富的策略性：每个人都是军事家&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;来到COC后，每个人都懂得摆阵设陷阱了，都懂得攻陷地方的弱点，都会装饰自己的领土了，在COC中，简直是人才济济！加农炮、箭塔、法师塔……这些都是和部落生死存亡性命攸关的家伙，一有金钱就将它们升级到最强，虽然耗费时间，但也乐在其中。最关键的还是大本营，是整个部落的实力和地位的体现。但是升大本营也是最虐心的，忘不了以前为了凑足200万升本，打到100多万时又怕被人抢，因此玩到深夜迟迟不下线，最终凑够200万心满意足升级了，时间已经从凌晨2点走到3点……
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-17&quot;&gt;游戏画面和战斗特效：赞！&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;说起COC,你第一个想到的是什么颜色呢？我想到的是金黄色，因为最喜欢的野蛮小人是金黄金黄的，飞龙喷出的火也是金黄金黄的，以及金子也是金黄金黄的，因此，COC的画面给我的感觉就是暖，和多彩。铿锵铿锵、砰轰砰轰，咻刷咻咻刷……刀剑砍墙的声音，大炮轰鸣的声音，以及弓箭飞驰的声音，COC中的音效和画面都非常到位，每个神力战士的技能也是炫酷到不行。还有一点让小编很喜欢的是，虽然每一场战争都可能有几十个几百个战士死亡，但是游戏丝毫没有血腥的感觉，战士们也多死得很安详，结束战争后，回到部落又能看到他们啦！因此，这款游戏，给我的感觉始终是愉快温暖的。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-18&quot;&gt;因为是第一个 所以经典&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;开发商Supercell带来了Clash of Clans《部落战争》这款新鲜血液之后，它的创新让许多玩家和厂商眼前一亮， 随后也有不少“仿制品”推出，但几乎没有一款能够脱颖而出，玩家们心中最珍爱的还是COC.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-19&quot;&gt;玩家人格魅力的体现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;人组成了一个部落，部落组成了一个世界，部落间的战争是人与人的战争，因此每一场COC的战斗中，都是个人魅力的体现。你的部落的排阵反应了你的个人策略；你的战斗习惯反应了你的心智，一个从来不复仇的人和一个有仇必报的人，在心智上必定有所不同；你的武器和部落的繁荣程度反应了你的消费程度和时间的使用习惯。因此，COC给我的感觉是热闹的，一个热热闹闹的充满人性的微型世界。
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;mt&quot;&gt;《我叫mt》&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;《我叫MT》是以“我叫MT”动画片为素材改编的第一款iOS平台上的卡牌社交网游，是根据同名动漫《我叫MT》改编而成的卡牌养成类手机网游。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-20&quot;&gt;画面&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;游戏的画面怎么说呢，与其去评论画面不如说这款游戏没什么画面。卡牌游戏你还想怎样？不过游戏中的UI设计很有魔兽的风格，让玩家即时再简单的游戏中也能够体会到原来的那种激情。另一个值得一提的就是他的怪物设定，游戏中的怪物除了动画中出现的还有很多开发商后来加入的怪物，风格与原作相差无几。虽然不知道他们是谁但是也可以看得出游戏的用心程度。
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;游戏用卡通的风格来演绎魔兽的画面，针对目标用户而做。画面质量在同类产品中处于上等，无论是场景的画质、卡牌的绘制质量，以及一些UE界面的描边；&lt;/li&gt;
  &lt;li&gt;战斗效果强于同类卡牌手机游戏产品，在6V6的战斗中，卡牌有移动效果、技能效果、打击受击动作，再伴随简单的音效、恰好的战斗节奏，带来的战斗爽快感、 可观赏性非常不错的，玩家在战斗中可以清楚地看到每一次打击、防御、治疗，可以帮助玩家选择战斗策略；&lt;/li&gt;
  &lt;li&gt;操作：竖版的界面设计降低了操作负担。在手握手机的情况下，只依靠大拇.指就能完成大多数的操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-21&quot;&gt;核心玩法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    以收集卡牌、组合卡牌、升级卡牌为核心乐趣，但在卡牌属性中，参照了魔兽世界以及动画片《我叫MT》的角色性格、职业特点，对于魔兽世界玩家或看过动画 片观众，可以轻松地在游戏里找到合适的策略，感受到游戏的乐趣所在。游戏中的卡牌分为《我是MT》动漫角色和非动漫角色，不同的卡片分类，拥有不同的成长 线，卡片可提升的品质等级不一样。其中来源于动漫角色的卡牌名字运用魔兽世界角色职业的音译，并且对名字做了有趣的改变。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-22&quot;&gt;游戏追求&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;收集卡牌之后就要去打FB，杀BOSS了，在战斗中我们会收集到金币、卡牌以及升级所需要装备。社交也是网络游戏的重点，玩家在战斗开始前可以邀请一名好陌生人来助阵，在结束战斗后可以加他为好友，这是建立交流的一个很好的方式
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;PVE方面对玩家实力规划区分做得比较好。PVE方面分为普通难度、精英难度、英雄难度，难度越高，获得的收益呈倍数增长，可以省去非常多的反复刷图时间，即达成花钱省时间的目标&lt;/li&gt;
  &lt;li&gt;游戏副本战斗前要求玩家选择一名玩家协助，战斗结束后可以添加这名玩家为好友，从而为玩家创造了一个建立新关系的的机会，玩家一方面可以在战斗中因为帮助 而胜利，也会因此获得友情点，而这个友情点也可用于抽奖。原版本缺乏竞技性的PVP元素，但是在即将推出的2.0版本将推出PVP竞技场，与副本设计相 似，游戏在竞技场的设计也会有难度区分，帮助不同级别的玩家找到游戏中竞技的乐趣。&lt;/li&gt;
  &lt;li&gt;游戏的攻略系统中提供了英雄图鉴、套装收集和攻略，从这些地方可以获得卡牌、装备以及游戏的有用信息，英雄图鉴中玩家可以查阅每一个卡牌的属性、技能以及获得方式，套装收集中则将拥有套装的数量，套装适用的英雄，套装的来源清晰地展现了出来。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-23&quot;&gt;游戏节奏&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;体力值恢复、定时副本是官方对玩家节奏控制的核心点，这两项设定确保了玩家对游戏有持续回访和关注的需求&lt;/li&gt;
  &lt;li&gt;在卡牌等级升级方面，通过套装收集、活动副本等方式，保证了卡牌升级具有阶梯性&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-24&quot;&gt;《刀塔传奇》&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;     这款游戏以DotA为蓝本，在卡牌游戏中加入了微操作的玩法，让玩家体验到了与众不同的游戏快感。因此，自从今年三月份上线之后，《刀塔传奇》的表现一直不俗：不仅赢得了众多玩家的心，更是一直包揽各大热门手游排行榜的榜首之位，还有媒体称它为“2014年不容错过的动作卡牌游戏”。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-25&quot;&gt;玩法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;《刀塔传奇》的玩法特别突出DotA中的团队配合，玩家在搭配出战英雄队形的时候要考虑到哪几个英雄的组合可以将战队的战斗力提升到最优，这样也在无形之中增加了游戏的策略性。相比起以前的只能干看着傻等的卡牌游戏而言，《刀塔传奇》整个游戏玩下来让玩家觉得自己对战斗的结果有更大的掌控权和主动性。游戏以推图副本为主，玩家组建战队后就会被引导进行战斗。每场战斗分为三小关，每关的时间限制为1.5分钟，战队中的英雄在被攻击时会积攒怒气值，积满怒气值之后就可以手动点击英雄释放必杀技。
值得一提的是，游戏的必杀技特效制作得特别的精美，在战斗的过程中玩家可以有真实的代入感；比如船长的必杀技就是一艘全屏的大船碾压过敌方战队并造成眩晕。令人赞叹的不仅是战斗中技能释放的逼真感，同时还有游戏内容的丰富性。当你对打副本战役感到厌倦的时候，游戏还提供了许多调剂的空间，还可以选择竞技场挑战PVP玩家、可以去时光之穴打宝箱、还可以去做燃烧的远征任务等等。在一次次的战斗中不断地收集英雄，组建更强力的战队，这个过程真的是其乐无穷；同时，游戏中不时出现的卖萌文案也总能博人一笑，成为让玩家爱不释手的一大亮点。
可以说，《刀塔传奇》出现之前，市场上并没有让人眼前一亮的加入微操作元素的卡牌游戏，这是这款游戏在玩法上最大的特色，也是它为何一直在排行榜上立于不败之地的重要原因。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-26&quot;&gt;画面&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;好的玩法搭配优质的画面，也是《刀塔传奇》的一大成功之处。游戏以Q版画风为主，每一幅地图场景、甚至战斗的场景都设计得相当精细；而作为一款卡牌游戏 ，《刀塔传奇》的每张英雄卡牌都刻画得相当用心，每一张卡牌的辨识度都很高、非常有特点，不会因为卡牌总数量太多而淹没在茫茫的卡牌海洋之中。基本上，你可以毫不费力地在英雄列表中一眼看出自己喜欢的英雄。《刀塔传奇》由于与DotA有着千丝万缕的关系，所以在画面和场景上也会让DotA玩家倍感亲切。另外，游戏中的每个英雄除了Q版的可爱形象之外还有一幅原画，点击英雄头像的时候可以展开到整个屏幕，让不少收集控大呼过瘾。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-27&quot;&gt;音效&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;在音效方面，总体可以打四颗星—《刀塔传奇》请了一大票明星来助阵为游戏里的英雄角色配音：比如巨乳女神柳岩来为火女配音，帅模特爸爸张亮为全能骑士配音，歌手胡夏为沉默配音等等；所以它标榜自己为 “最声动卡牌手游”也不为过。另外，游戏的主旋律也是比较激动人心的快节奏旋律，让人听起来就有想要开始战斗的激情。美中不足的是，游戏的其他音效做得比较一般，中规中矩得让人玩过之后并没有留下太大的印象。但作为一款主打战斗和策略的卡牌游戏，《刀塔传奇》的音效表现也算是不错了。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-28&quot;&gt;操作&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;就操作而言，《刀塔传奇》非常有特色。在英雄战斗的时候，玩家不会再扮演一个只能在旁边干瞪眼的旁观者，而是在战斗开始之时就要时时留意英雄们的怒气值，在怒气值满的时候迅速释放技能。并且由于有的英雄有打断技能，所以在恰当的时间释放技能往往成为影响整个战局的关键。不过在操作上，《刀塔传奇》并不是一款复杂的游戏，相反，可以说这是一款在操作上十分便捷的游戏。玩家只需要在相应英雄怒气值满的时候释放技能即可，游戏设置在再次进入已经通关的关卡时可以选择自动战斗，减少了玩家大量重复操作产生的枯燥感；甚至在PVP竞技场中系统被设定成为自动战斗模式，全面考验玩家在战前对队伍整体战斗力的运筹帷幄，而远征中的战斗也让每一个辛苦培养出来的英雄都得以彰显价值和发挥作用。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-29&quot;&gt;收费&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;《刀塔传奇》在苹果商店中国区目前可以免费下载，游戏中会有购买月卡、充值VIP、购买礼包等内购的内容。不过即使不是RMB战士，也还是有机会通过时间、积累跨过各种消费门槛。得益于游戏中相对平衡的数值设定和丰富精彩的玩法内容，各个阶层的玩家都能找到属于自己的乐趣，轻松享受游戏，没有任何负担。
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;deemo&quot;&gt;《Deemo》（《古树旋律》）&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;一直以来认为音乐游戏应该分为两派。一派是追求华丽谱面和复杂判定形式的快感系，多以电音、舞曲为主，而另一派应该是注重意境氛围的乐感系，多以情绪化的小编制室内乐为主。近年来国内音乐游戏市场多半发展得大同小异，可喜的是素有“华人之光”之称的雷亚公司坚持原创的道路，在Cytus获得不俗的成绩后，近日推出新系列的文艺范音乐游戏《Deemo》，这个满满钢琴乐感的纯正音乐游戏也打破了华人音乐游戏缺乏剧情内涵的惯例。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-30&quot;&gt;概述我见：朴实包装下浓浓的音乐呈现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;《Deemo》以优秀的编曲、强烈的氛围营造、弹奏感十足的钢琴模拟，汇聚成一款醇正浓郁的音乐游戏。但另一方面来说其又是不成熟的，过于朴实的谱面设计、过于追求乐感的判定，过于单调的操作体系,对于当下普遍“注重其表”的玩家来说，显然不够讨喜。但这个敢于以异类姿态出现的家伙，不仅仅是一个简单的游戏，它也可以是：音乐而已。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-31&quot;&gt;外在表现：简约勾勒间满满的氛围表现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;在这个时代，游戏表现力不断在刷新突破着极限，而有一种风格却历经时代洗礼依然璀璨耀眼，便是被美誉为“寄宿了作者灵魂”的手绘展现。这种基于人类情感表达使动下而萌生的艺术行为，富含着高超的情绪表现力，往往在看似简约的线条之间，蕴含着深不可测的另一个世界。《Deemo》正是选择了这样符合音乐渲染效果的表现方式，营造出强烈的共鸣画面。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-32&quot;&gt;最刺骨的孤独&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;从天而降的少女打破了钢琴家的宁静，却让光明照亮了这片幽禁之地
游戏在纯手绘风格加上柔和的光源渲染下烘托出教人辛酸的孤独。当玩家投入到主角Deemo的情感中去，随着游戏进展慢慢接近与天降之物离别的终途..就会发现，在充满生机的画面背后，始终埋藏着Deemo那份无法背弃的孤独。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-33&quot;&gt;最揪心的归宿&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;而游戏的另一项表现特色就是随着剧情进展而出现的彩铅风格过场。和主基调的水粉画不同，彩铅勾勒出的过场少了几分忧郁和迷茫，多了更多的愉悦和童话色彩的欢乐张扬…这种反差强烈的过场形式能进一步让玩家投入到游戏的氛围中去，从而在毫无戒备的情况下走向最揪心的归宿。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-34&quot;&gt;最伤感的领悟&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;自从DJ MAX广为人知后，同类音乐游戏的选曲便脱离不了仿CD封面的单曲插画表现形式了。这点上《Deemo》并没有突破，但值得一提的是该游戏中所设计的封面效果不仅和歌曲本身风格十分切合，同时还具备了极强的张力，其中蕴含冷冽的伤感情怀，玩家只要投入足够的想象就能领悟。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-35&quot;&gt;最华丽的礼物&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;《Deemo》为玩家筹备了相当华丽的音乐阵容，不仅有着Mili、M2U等从Cytus就开始备受关注的御用制作人的精心打造，V•K、植松伸夫等知名作曲家的倾力加盟更是极大地拔高了该作的水准高度。多元化的BGM都是中毒性满满的好物，对于一个杂食的音乐控玩家来说，该作是富含新世纪音乐色彩的最佳礼物。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-36&quot;&gt;内涵理念：童话故事后深刻的亲情体现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;《Deemo》的故事是塑造得非常棒的，从表里两个深度来看具备了完全不同的内涵体现。表面上看，这是充满稚趣色彩的童话情节，孤独的Deemo在钢琴的陪伴下静度着岁月，从头而降的少女打破了平静，也给了他从所未有的温馨体验..而快乐的时光总要终结，Deemo最终仍旧用钢琴唤醒沉睡的古树，将少女送回原来的世界…回归孤独，唯有再次响起的钢琴声证明了曾发生过的一切
而深入的从各方面剖析来看，不难了解这讲述的其实是一个关于亲情的故事。歌曲 “Dream”中途出现的杂乱声预示着少女遭遇了灾祸处在生死边缘，而慢慢陷入了沉眠，降临了Deemo的世界。而Deemo正是她逝世的父亲，伴随着戴着面具的母亲一起在冥府中守望着永恒的长夜。女儿的到来打破了宁静，母亲希望留下她慰藉孤独已久的心灵..可女儿憧憬着回归美好的生命..在复杂情感的抉择中，Deemo做出了一个父亲的决定，亲手奏响苏生的钢琴曲，一步步将女儿还给了光明彼方的生命…而那些美好共奏的诗篇，将烙印在两个世界彼此的心灵
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-37&quot;&gt;特色提炼：黑白键盘上盛放的心灵盛宴&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;《Deemo》是一款自始至终注重意境表现的音乐游戏，如同岁乐纪一般。不论是追求乐感的极致表现、还是细致入微的氛围呈现，在黑白分明的键盘式演奏中，都给予人波涛汹涌的心灵震撼。
和通常音乐游戏拥有完善且华丽的操作体验不同，《Deemo》仅有着简单的音符下落、和连续音符滑动两种操纵方式需要留意。在判定上也是以金、绿、蓝三色分别代表perfect、great、miss来简单代过。
令人意外的是，极其简单的操作却衍生了非同寻常的乐感，尤其是实际操作过程中强烈的钢琴演奏手感（=-=需亲身体会）让人惊叹。在游戏过程中以一个称职钢琴伴奏员的身份代入游戏中去，更易在满天袭来的音符中坐怀不乱；一味对着线和音符狂掐死按，成绩通常都会很惨。很显然，比起眼疾手快的目押，这游戏更需要的是乐感。
游戏中的诸多细节设定也为烘托氛围贡献了巨大的助力。在几首歌后就会出现类似“家”的房间，除了给玩家带来些许温馨的对话场面填充剧情外，过场鉴赏模式、隐藏歌曲搜索、以及扩充音乐DLC包的购买下载功能也巧妙地通过设计集成在场景元件内。
而作为游戏主场景存在的古树琴台，也设置了顺应剧情进展而产生变化的对话内容。除了为游戏角色增添更多人性化表现外，也在其中铺设交代了剧情悬念的分析细节。与房间类似的是，该场景下依旧存在可触发反应的元件部位，厂商在细节雕琢上的用心可见一斑。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-38&quot;&gt;一些不足&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;综合整体来看，《Deemo》是一款优秀的音乐游戏，它已经超出吾辈最初的预期，但同时不得不承认在某些点上，其确实难以让所有人都满意，因此它的问世必然引来观点对立的争议。
创新是一柄双刃剑。没有界定判定区的操作体验可以算作是雷亚的创新。这种做法一方面极大地优化了玩家游玩时候的真实演奏体验，但同时也极大的破坏了游戏的丰富度，对于那些视华丽谱面和复杂操作为最大乐趣的玩家来说，这种忠于乐感的设定显得过于平淡无味，感受不到乐趣。
商业是一种黑哲学。《Deemo》中的音乐非常耐听，并且风格多变。有跌宕氛围、有诡异宗教、着毒性电音、也有古朴典雅…但仔细倾听却不难发现它们的通病。这些音乐低频下潜不足显得轰头、中频人声距离处理不当容易影响器乐声场、高频毛刺颇多并且存在齿音情况…这样的效果显得太过混杂，解析力不足更不要提呈像化..实际上某菌研究了网上有人放出的原声音乐提取包后，发觉这些160kps码率MP3构成的音质显然算不上无损转制，很明显Hifi级别的音质必须期待厂商惯例发行OST原声集才是
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 27 Feb 2015 17:45:00 +0800</pubDate>
        <link>/2015/02/27/%E5%A6%B9%E5%AD%90%E9%9D%A2%E8%AF%95%E5%A4%87%E5%BF%98/</link>
        <guid isPermaLink="true">/2015/02/27/%E5%A6%B9%E5%AD%90%E9%9D%A2%E8%AF%95%E5%A4%87%E5%BF%98/</guid>
        
        
        <category>other</category>
        
      </item>
    
      <item>
        <title>bsd socket api</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#int-socket--int-family-int-type-int-protocol&quot;&gt;int socket ( int family, int type, int protocol)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#int-socketbind--int-sockfd-const-struct-sockaddr-myaddr-int-addrlength&quot;&gt;int socket_bind ( int sockFD, const struct sockaddr *myAddr, int addrLength)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#int-socketconnectint-sockfd-struct-sockaddr-servaddr-int-addrlength&quot;&gt;int socket_connect(int sockFD, struct sockaddr *servAddr, int addrLength)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#int-socketselectint-maxfdsexamined-fdset-readfds-fdset-writefds-fdset-exceptfds-struct-timeval-timeout&quot;&gt;int socket_select(int maxFDsExamined, fd_set *readFDs, fd_set *writeFDs, fd_set *exceptFDs, struct timeval *timeOut)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#socketfcntlint-sockfd-int-command-int-flags&quot;&gt;socket_fcntl(int sockFD, int command, int flags)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#int-socketgetpeernameint-sockfd-struct-sockaddr-peeraddr-int-addrlength&quot;&gt;int socket_getpeername(int sockFD, struct sockaddr *peerAddr, int *addrLength)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#int-socketgetsocknameint-sockfd-struct-sockaddr-localaddr-int-addrlength&quot;&gt;int socket_getsockname(int sockFD, struct sockaddr *localAddr, int *addrLength)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#int-socketreadint-sockfd-void-buffer-uint32-numbytes&quot;&gt;int socket_read(int sockFD, void *buffer, UInt32 numBytes)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#int-socketwriteint-sockfd-void-buffer-uint32-numbytes&quot;&gt;int socket_write(int sockFD, void *buffer, UInt32 numBytes)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#int-socketreadvint-sockfd-struct-iovec-iov-uint32-iovcount&quot;&gt;int socket_readv(int sockFD, struct iovec *iov, UInt32 iovCount)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#int-socketrecvint-sockfd-void-buffer-uint32-numbytes-int-flags&quot;&gt;int socket_recv(int sockFD, void *buffer, UInt32 numBytes, int flags)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#int-socketsendint-sockfd-void-buffer-uint32-numbytes-int-flags&quot;&gt;int socket_send(int sockFD, void *buffer, UInt32 numBytes, int flags)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#int-socketrecvfromint-sockfd-void-buffer-uint32-numbytes-int-flags-struct-sockaddr-fromaddr-socklent-addrlength&quot;&gt;int socket_recvfrom(int sockFD, void *buffer, UInt32 numBytes, int flags, struct sockaddr *fromAddr, socklen_t *addrLength)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#int-socketsendtoint-sockfd-void-buffer-uint32-numbytes-int-flags-struct-sockaddr-toaddr-socklent-addrlength&quot;&gt;int socket_sendto(int sockFD, void *buffer, UInt32 numBytes, int flags, struct sockaddr *toAddr, socklen_t addrLength)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#int-socketshutdownint-sockfd-int-howto&quot;&gt;int socket_shutdown(int sockFD, int howTo)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#int-socketcloseint-sockfd&quot;&gt;int socket_close(int sockFD)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;int-socket--int-family-int-type-int-protocol&quot;&gt;int socket ( int family, int type, int protocol)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;创建一个socket，返回一个socket描述符&lt;code&gt;sockFD&lt;/code&gt;，可以理解为一个句柄,是一个small无符号整数,这个句柄可以使用所有其他的socket操作，返回-1时表示跪了   &lt;/li&gt;
      &lt;li&gt;family: 当前协议族只能是&lt;code&gt;AF_INET&lt;/code&gt;,因为没有支持IPv6，所以没有AF_INET6&lt;/li&gt;
      &lt;li&gt;type: &lt;code&gt;SOCK_STREAM&lt;/code&gt;是tcp流式，&lt;code&gt;SOCK_DGRAM&lt;/code&gt;是udp数据包式&lt;/li&gt;
      &lt;li&gt;protocol: &lt;code&gt;PF_INET&lt;/code&gt;或者是&lt;code&gt;PF_UNSPEC&lt;/code&gt;,两者都可以，前者只能接受v4的协议，后者通吃。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;int-socketbind--int-sockfd-const-struct-sockaddr-myaddr-int-addrlength&quot;&gt;int socket_bind ( int sockFD, const struct sockaddr *myAddr, int addrLength)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;绑定一个socket到本地的端口&lt;em&gt;and/or&lt;/em&gt;ip地址，不管是ip还是port都可以在库自动选择的情况下得到通配，通配port的话，把address中&lt;code&gt;sin_port&lt;/code&gt;域设置0，通配ip的话，把address中的&lt;code&gt;sin_addr.s_addr&lt;/code&gt;设置0，和socket()一样，返回-1表示跪了，返回0表示ok&lt;/li&gt;
      &lt;li&gt;tcp有一个端口重用时限机制，如果一个应用试图连续在短时间内第二次绑定同一个本地端口，会出现一个EADDRINUSE错误，等等就好了(这也行。。。)&lt;/li&gt;
      &lt;li&gt;注意第二个参数，本质上是一个&lt;code&gt;struct sockaddr_in*&lt;/code&gt;，被转换成了一个更加通用的&lt;code&gt;struct sockaddr*&lt;/code&gt;，因为网络地址是被Socket Library所使用（这儿不太懂）&lt;/li&gt;
      &lt;li&gt;不是必须在connect之前使用bind，如果一个socket没有绑定的话，库会选择本地的port和ip&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;int-socketconnectint-sockfd-struct-sockaddr-servaddr-int-addrlength&quot;&gt;int socket_connect(int sockFD, struct sockaddr *servAddr, int addrLength)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;通过一个给定的port连接远程主机，如果这是一个流式(tcp)socket,会执行一个tcp协商(negotation)来打开一个连接，如果是数据报式(udp)socket，会把地址存储起来，之后会和某些socket操作一起作用，这里比较重要的一点就是，使用udp的情况下，不需要握手，只有根据通信时有没有数据包来判断是否连接成功，所以在通过这个socket进行读写的情况下才会报错。返回-1给跪，0ok&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;int-socketselectint-maxfdsexamined-fdset-readfds-fdset-writefds-fdset-exceptfds-struct-timeval-timeout&quot;&gt;int socket_select(int maxFDsExamined, fd_set *readFDs, fd_set *writeFDs, fd_set *exceptFDs, struct timeval *timeOut)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;可以轮询一个或多个socket，常用于实现非阻塞socket编程,同样error返回-1（这个函数篇幅有限，详情百度）&lt;/li&gt;
      &lt;li&gt;maxFDsExamined: 描述轮询的句柄范围，要比最大的socket句柄都要大,起兼容作用，windows上无所谓，可以忽略&lt;/li&gt;
      &lt;li&gt;readfds：（可选）指针，指向一组等待可读性检查的套接口。&lt;/li&gt;
      &lt;li&gt;writefds：（可选）指针，指向一组等待可写性检查的套接口。&lt;/li&gt;
      &lt;li&gt;exceptfds：（可选）指针，指向一组等待错误检查的套接口。&lt;/li&gt;
      &lt;li&gt;timeout：select()最多等待时间，对阻塞操作则为NULL，{0,0}表示立即返回，非阻塞。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;socketfcntlint-sockfd-int-command-int-flags&quot;&gt;socket_fcntl(int sockFD, int command, int flags)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;可以改变一个已经打开的socketFD句柄属性，目前唯一支持的flag是&lt;code&gt;O_NONBLOCK&lt;/code&gt;，可以把socket变为非阻塞模式&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;command: 等于&lt;code&gt;F_GETFL&lt;/code&gt;的时候，返回这个sockFD当前的flag，等于&lt;code&gt;F_SETFL&lt;/code&gt;的时候，将后面传入的flags参数设置为sockFD的flag，error时返回-1比较正统的方法如下&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  lags = socket_fcntl(sockfd, F_GETFL,0）;
  flags |= O_NONBLOCK;
  err = socket_fcntl(sockefd, F_SETFL, flags);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;int-socketgetpeernameint-sockfd-struct-sockaddr-peeraddr-int-addrlength&quot;&gt;int socket_getpeername(int sockFD, struct sockaddr *peerAddr, int *addrLength)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;获取远程主机的地址，成功返回0，如果没有之前没有连接成功，GetMITLibError()会返回ENOTCONN错误，且返回-1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;int-socketgetsocknameint-sockfd-struct-sockaddr-localaddr-int-addrlength&quot;&gt;int socket_getsockname(int sockFD, struct sockaddr *localAddr, int *addrLength)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;获取该socket的本地port和address，0成功，-1失败&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;int-socketreadint-sockfd-void-buffer-uint32-numbytes&quot;&gt;int socket_read(int sockFD, void *buffer, UInt32 numBytes)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;从socket中将数据读取到buffer中，numBytes应该是buffer的大小，read函数可能不会装满这个buffer，返回值是所读取数据的大小，失败返回-1，如果返回0，说明socket收到了一个EOF（比如远程主机关闭了）&lt;/li&gt;
      &lt;li&gt;如果在socket上想要完整的执行读取，在读满自己希望的大小之前继续调用read，值得注意的是，如果没有数据可读的时候，read函数会阻塞，这个状态可以通过select查看到。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;int-socketwriteint-sockfd-void-buffer-uint32-numbytes&quot;&gt;int socket_write(int sockFD, void *buffer, UInt32 numBytes)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;把numBytes大小的数据从buffer中写入到socket里，同样，write可能也不会把buffer全部写入，返回值是实际写入的大小，失败返回-1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;int-socketreadvint-sockfd-struct-iovec-iov-uint32-iovcount&quot;&gt;int socket_readv(int sockFD, struct iovec *iov, UInt32 iovCount)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;等价于read，但是会把数据存放在iov数组的成员里：iov[0],iov[1]…iov[iovCount-1],iovCount的取值范围是(0,IOV_MAX]，把数据分散存放&lt;/li&gt;
      &lt;li&gt;struct iovec的两个成员：&lt;code&gt;caddr_t iov_base&lt;/code&gt;和&lt;code&gt;int iov_len&lt;/code&gt;，前者是数据存放的首地址，后者是该数据片的长度，readv函数会按顺序填充这些数据片&lt;/li&gt;
      &lt;li&gt;返回值是读取数据的总大小，失败时返回-1,0是EOF&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;int-socketrecvint-sockfd-void-buffer-uint32-numbytes-int-flags&quot;&gt;int socket_recv(int sockFD, void *buffer, UInt32 numBytes, int flags)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;这个函数和read很像，除了最后一个参数，如果flags被设置为&lt;code&gt;MSG_DONTWAIT&lt;/code&gt;，那么当数据不可用的时候这个函数会变成非阻塞。&lt;/li&gt;
      &lt;li&gt;返回值是读取的数据的总数，返回-1时error&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;int-socketsendint-sockfd-void-buffer-uint32-numbytes-int-flags&quot;&gt;int socket_send(int sockFD, void *buffer, UInt32 numBytes, int flags)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;和write相似，同样如果flags被设置为&lt;code&gt;MSG_DONTWAIT&lt;/code&gt;时，此函数会变为非阻塞。&lt;/li&gt;
      &lt;li&gt;返回值是写入的数据的总数，返回-1时error&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;int-socketrecvfromint-sockfd-void-buffer-uint32-numbytes-int-flags-struct-sockaddr-fromaddr-socklent-addrlength&quot;&gt;int socket_recvfrom(int sockFD, void *buffer, UInt32 numBytes, int flags, struct sockaddr *fromAddr, socklen_t *addrLength)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;从fromAddr指定的远程主机读取信息，要求socket必须为数据报式(udp)，numBytes是buffer的大小，不保证填满buffer，返回值是读取数据的总大小，失败时返回-1&lt;/li&gt;
      &lt;li&gt;如果flags被设置为&lt;code&gt;MSG_DONTWAIT&lt;/code&gt;时，此函数会变为非阻塞&lt;/li&gt;
      &lt;li&gt;fromAddr本质上是一个struct sockaddr_in*类型&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;int-socketsendtoint-sockfd-void-buffer-uint32-numbytes-int-flags-struct-sockaddr-toaddr-socklent-addrlength&quot;&gt;int socket_sendto(int sockFD, void *buffer, UInt32 numBytes, int flags, struct sockaddr *toAddr, socklen_t addrLength)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;向toAddr指定的远程主机发送信息，要求socket必须为数据报式(udp)，numBytes是要发送数据的大小，不保证全部输出buffer，返回值是读取数据的总大小，失败时返回-1&lt;/li&gt;
      &lt;li&gt;如果flags被设置为&lt;code&gt;MSG_DONTWAIT&lt;/code&gt;时，此函数会变为非阻塞&lt;/li&gt;
      &lt;li&gt;fromAddr本质上是一个struct sockaddr_in*类型&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;int-socketshutdownint-sockfd-int-howto&quot;&gt;int socket_shutdown(int sockFD, int howTo)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;单向或者双向的关闭一个连接着的socket，返回0是ok，-1是error&lt;/li&gt;
      &lt;li&gt;howTo：
        &lt;ul&gt;
          &lt;li&gt;&lt;code&gt;SHUT_RD&lt;/code&gt;关闭正在read的端，这时socket便不再可读&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;SHUT_WR&lt;/code&gt;关闭正在write的端，这时socket会向远程主机发送一个断开的指令，告诉对方这里已经不会再write任何东西，不再可写&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;SHUT_RDWR&lt;/code&gt;关闭连接的两端，之后依旧需要使用close来释放掉socket&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;int-socketcloseint-sockfd&quot;&gt;int socket_close(int sockFD)&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;释放掉一个socket的资源，与远程主机断开连接，这是必须要有的，不管tcp还是udp都需要执行这一步，返回0是ok，-1是error&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;转载请注明出处&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Jan 2015 19:44:00 +0800</pubDate>
        <link>/2015/01/07/bsd-socket-api/</link>
        <guid isPermaLink="true">/2015/01/07/bsd-socket-api/</guid>
        
        
        <category>network</category>
        
      </item>
    
  </channel>
</rss>
